* Modes and Packages

  Modes bring significant functionality into Emacs. These are the
  modes (and any associated configuration) that I use.

  As I understand it, modes are delivered via packages. You can browse
  available packages by typing =M-x package-list-packages=. As you
  move around (just like a regular buffer), if you see something you
  like you can press =i= and the package on the same line as your
  cursor will be marked for an upcoming installation. When you are
  ready, press 'x' to install each package that has been marked in
  this way.

  If I like a package, I'll revisit this file and formally add it to
  the list of packages I use. In this file, my intent is to provide
  notes about a mode, why I am using it, what I am doing with it,
  etc. Further, I want to hook the list of packages that I am using
  into a system by which they are automatically installed. I am
  looking to do this to make sure that I can recreate my emacs
  installation if I move to a new computer. The means by which
  packages are automatically installed is with a function named
  =sacha/package-install=. This was defined previously.

** General Package Listing

*** better-defaults

    I started with Emacs Starter Kit, and am following its progression
    from v1 to v2 and, now, v3. In v3 the esk becomes prose only, and
    identifies =better-defaults= as a single package with "universal
    appeal."

#+begin_src emacs-lisp
  (sacha/package-install 'better-defaults)
#+end_src

*** smex

    When you want to run a command (say, via M-x) [[https://github.com/nonsequitur/smex][smex]] provides
    instant feedback by displaying available commands and remembering
    ones you have recently invoked.

#+begin_src emacs-lisp
  (sacha/package-install 'smex)
  (setq smex-save-file (concat user-emacs-directory ".smex-items"))
  (smex-initialize)
  (global-set-key (kbd "M-x") 'smex)
#+end_src

*** flx-ido

    [[https://github.com/lewang/flx][flx-ido]] is a package written with the idea of bringing Sublime
    Text's fuzzy search to Emacs.

    It enhances =ido=, and so the configuration below turns on ido,
    turns on flx-ido, uses ido for all buffer/file reading, and
    finally disables ido's style of highlighting. In constrast to
    Ido's highlighting, flx-ido provides insight into which actual
    characters are causing the hits.

#+BEGIN_SRC emacs-lisp
  (sacha/package-install 'flx-ido)
  (require 'flx-ido)
  (ido-mode 1)
  (ido-everywhere 1)
  (flx-ido-mode 1)
  (setq ido-use-faces nil)
#+END_SRC

*** ace-jump-mode

#+begin_src emacs-lisp
  (sacha/package-install 'ace-jump-mode)
  (require 'ace-jump-mode)
  (define-key global-map (kbd "C-c SPC") 'ace-jump-mode)
#+end_src

*** markdown-mode

  I write in Markdown all the time, and sometimes I use the
  "compilation" facility of this mode.

  If you do start using the compilation aspect, you'll need a command
  line "markdown" to execute.

  I got markdown with =brew install markdown=.

  My notes indicate that:

    You can change the markdown executable, or read more about the
    mode, here: http://jblevins.org/projects/markdown-mode/

    Also, Highlights:

    + =C-c C-c p=: Run markdown on buffer contents. Open result in
      browser.

  I started using markdown-mode+ recently, and I did so after doing a
  bunch of work to get pandoc installed and working with Emacs.

#+begin_src emacs-lisp
  (sacha/package-install 'markdown-mode)
  (sacha/package-install 'markdown-mode+)
  (add-to-list 'auto-mode-alist '("\\.md$" . markdown-mode))
#+end_src

*** puppet-mode

#+begin_src emacs-lisp
  (sacha/package-install 'puppet-mode)
  (add-to-list 'auto-mode-alist '("\\.pp$" . puppet-mode))
#+end_src

*** haml-mode

#+begin_src emacs-lisp
  (sacha/package-install 'haml-mode)
#+end_src

*** slim-mode

#+begin_src emacs-lisp
  (sacha/package-install 'slim-mode)
#+end_src

*** yaml-mode

#+begin_src emacs-lisp
  (sacha/package-install 'yaml-mode)
  (add-to-list 'auto-mode-alist '("\\.yml$" . yaml-mode))
#+end_src

*** coffee-mode

    I love CoffeeScript, and I love editing CoffeeScript, but I was
    confused by =coffee-mode=. It brings a neat approach for "what
    should happen when you press TAB," but I was thrown off by the
    size of the indents. At first it was defaulting to 8 spaces when I
    wanted 2.

    I got my two space indent from the hook defined below. The same
    hook also sets it up so that pressing "Command C" *compiles* the
    CoffeeScript and displays the resulting JavaScript in a new
    window.

    To get compilation going, I did an =npm install -g coffee=. This
    meant the =coffee= executable is installed at
    =/usr/share/local/npm/bin=. This directory is in my path via
    =jedcn-env-path=.

#+begin_src emacs-lisp
  (sacha/package-install 'coffee-mode)

  (defun jedcn-coffee-custom ()
    "jedcn's coffee-mode-hook"
    (define-key coffee-mode-map [(meta c)] 'coffee-compile-buffer)
    (make-local-variable 'tab-width)
    (set 'tab-width 2))

  (add-hook 'coffee-mode-hook '(lambda () (jedcn-coffee-custom)))
#+end_src

*** scss-mode

#+BEGIN_SRC emacs-lisp
  (sacha/package-install 'scss-mode)
#+END_SRC

*** js-mode

    I love JavaScript.

#+BEGIN_SRC emacs-lisp
  (setq js-indent-level 2)
#+END_SRC

*** flycheck

    I've just learned about flycheck, and am experimenting with it
    now.

    In some cases it relies on external tools to check for it. The
    tools that I am presently making use of are:

    - jshint :: via =npm install -g jshint=
    - jsonlint :: via =npm install -g jsonlint=
    - coffeelint :: via =npm install -g coffeelint=

    I make sure these are available to emacs by making sure that the
    location that npm puts stuff (=/usr/local/share/npm/bin=) is in my
    =jedcn-env-path=.

    Nah. This isn't working for me. Too aggressive. Will come back
    another time.

#+BEGIN_SRC emacs-lisp
;;  (sacha/package-install 'flycheck)
;;  (add-hook 'after-init-hook #'global-flycheck-mode)
#+END_SRC

*** diminish

    In Emacs, the "mode line" shows you information about the active
    major and any active minor modes. In some cases this is helpful
    and in other cases this is just "noise." The diminish library
    allows you to eliminate (or change) contributions that packages
    make to the mode line.

    I found out about it through this [[http://whattheemacsd.com/init.el-04.html][post]]. It lives [[http://www.eskimo.com/~seldon/diminish.el][here]].

    You can see which modes have been diminished with
    =diminished-modes=.

    You
#+BEGIN_SRC emacs-lisp
  (sacha/package-install 'diminish)
  (eval-after-load "yasnippet" '(diminish 'yas-minor-mode))
  (diminish 'auto-fill-function)
#+END_SRC
** Project Management

   I use a combination of project-persist and projectile for project
   management in emacs. Persist lets me manage a "list of projects,"
   and I can generate this list from the layout of my file
   system.

   Once I've got that, Persist lets me open and close projects, and
   Projectile gives me a helpful "find file in project."

*** projectile

#+BEGIN_SRC emacs-lisp
  (sacha/package-install 'projectile)
  (require 'projectile)
#+END_SRC

*** project-persist

    [[https://github.com/rdallasgray/project-persist][project-persist]] is a lightweight means for keeping track of
    projects. Projects have names and a location on your file
    system. Optionally, they can have settings associated with them.

    That said, you can use project-persist to find a project and close
    a project, and project-persist provides hooks into these events.

**** Basic Installation

#+BEGIN_SRC emacs-lisp
  (sacha/package-install 'project-persist)
  (project-persist-mode t)
#+END_SRC

**** File System Integration

     I layout code on my computer in the following manner:

     + ~/c/misc :: Miscellaneous projects live here.
     + ~/c/personal :: Personal projects live here.
     + ~/d :: Code that I don't author, but that I look at
              semi-regularly lives here.

     For example, if I checkout the source for rake on my computer and I
     just scan through it, it lives at =~/d/rake/=. If I am actively
     working on a project named reveal-ck, it lives at
     =~/c/personal/reveal-ck/=.

     I capture these locations in =jedcn/pp-project-roots=.

     The following code scans through these directories and builds
     project-persist entries for each directory that is found. The
     main interactive entry point is =jedcn-pp/rebuild-projects=.

#+BEGIN_SRC emacs-lisp

  (require 'project-persist)

  (setq jedcn/pp-project-roots
        (list (concat (getenv "HOME") "/c/galileo")
              (concat (getenv "HOME") "/c/misc")
              (concat (getenv "HOME") "/c/personal")
              (concat (getenv "HOME") "/d")))

  (defun jedcn/pp-create-projects-under-root (root)
    "Create project-persist projects for directories under root"
    (let* ((dirs (directory-files root))
           (dir (car dirs))
           (ignore-dirs '("." ".." ".DS_Store")))
      (while dirs
        (unless (member dir ignore-dirs)
          (unless (pp/project-exists dir)
            (pp/project-setup (concat root "/" dir "/") dir)))
        (setq dirs (cdr dirs))
        (setq dir (car dirs)))))

  (defun jedcn/pp-create-all-projects (project-roots)
    "Create all project-persist projects based on PROJECT-ROOTS"
    (let* ((project-root (car project-roots)))
      (while project-roots
        (jedcn/pp-create-projects-under-root project-root)
        (setq project-roots (cdr project-roots))
        (setq project-root (car project-roots)))))

#+END_SRC

**** Hooks

     project-persist is intentionally minimal, so, to get something
     out of it you need to register hooks into its main events. These
     revolve around project management.

     It can integrate with projectile via a shared global variable
     named =default-directory=. If project-persist sets this
     variable, then projectile will pick up on it and focus searches
     underneath it.

#+BEGIN_SRC emacs-lisp
  (global-set-key "\M-1" 'project-persist-find)
  (global-set-key "\M-2" 'projectile-find-file)
#+END_SRC

*** graphene

    Graphene is a great package, but there are parts of it I'm not yet
    ready for just yet (autocomplete, smartparens). Consequently, I've
    inlined copies of it here.

**** graphene-helper-functions.el

#+BEGIN_SRC emacs-lisp
  (defun kill-default-buffer ()
    "Kill the currently active buffer -- set to C-x k so that users are not asked which buffer they want to kill."
    (interactive)
    (let (kill-buffer-query-functions) (kill-buffer)))

  (defun kill-buffer-if-file (buf)
    "Kill a buffer only if it is file-based."
    (when (buffer-file-name buf)
      (when (buffer-modified-p buf)
          (when (y-or-n-p (format "Buffer %s is modified - save it?" (buffer-name buf)))
              (save-some-buffers nil buf)))
      (set-buffer-modified-p nil)
      (kill-buffer buf)))

  (defun kill-all-buffers ()
      "Kill all file-based buffers."
      (interactive)
      (mapc (lambda (buf) (kill-buffer-if-file buf))
       (buffer-list)))

  (defun kill-buffer-and-window ()
    "Close the current window and kill the buffer it's visiting."
    (interactive)
    (progn
      (kill-buffer)
      (delete-window)))

  (defun create-new-buffer ()
    "Create a new buffer named *new*[num]."
    (interactive)
    (switch-to-buffer (generate-new-buffer-name "*new*")))

  (defun insert-semicolon-at-end-of-line ()
    "Add a closing semicolon from anywhere in the line."
    (interactive)
    (save-excursion
      (end-of-line)
      (insert ";")))

  (defun comment-current-line-dwim ()
    "Comment or uncomment the current line."
    (interactive)
    (save-excursion
      (push-mark (beginning-of-line) t t)
      (end-of-line)
      (comment-dwim nil)))

  (defun newline-anywhere ()
    "Add a newline from anywhere in the line."
    (interactive)
    (end-of-line)
    (newline-and-indent))

  (defun increase-window-height (&optional arg)
    "Make the window taller by one line. Useful when bound to a repeatable key combination."
    (interactive "p")
    (enlarge-window arg))

  (defun decrease-window-height (&optional arg)
    "Make the window shorter by one line. Useful when bound to a repeatable key combination."
    (interactive "p")
    (enlarge-window (- 0 arg)))

  (defun decrease-window-width (&optional arg)
    "Make the window narrower by one line. Useful when bound to a repeatable key combination."
    (interactive "p")
    (enlarge-window (- 0 arg) t))

  (defun increase-window-width (&optional arg)
    "Make the window shorter by one line. Useful when bound to a repeatable key combination."
    (interactive "p")
    (enlarge-window arg t))

  ;; Create a new instance of emacs
  (when window-system
    (defun new-emacs-instance ()
      (interactive)
      (let ((path-to-emacs
             (locate-file invocation-name
                          (list invocation-directory) exec-suffixes)))
        (call-process path-to-emacs nil 0 nil))))
#+END_SRC

**** graphene-speedbar.el

     Some setup is necessary to use graphene-speedbar.el. I make sure
     I've got sr-speedbar installed and I define
     =graphene-speedbar-refresh-hooks= (which is normally defined in
     graphene.el).

#+BEGIN_SRC emacs-lisp
  (sacha/package-install 'sr-speedbar)
  (require 'sr-speedbar)

  (defvar graphene-speedbar-refresh-hooks '(after-save-hook)
    "List of hooks which on being run will cause speedbar to refresh.")

  (global-set-key (kbd "M-s") 'sr-speedbar-toggle)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (setq speedbar-hide-button-brackets-flag t
        speedbar-show-unknown-files t
        speedbar-smart-directory-expand-flag t
        speedbar-directory-button-trim-method 'trim
        speedbar-use-images nil
        speedbar-indentation-width 2
        speedbar-use-imenu-flag t
        speedbar-file-unshown-regexp "flycheck-.*"
        sr-speedbar-width 40
        sr-speedbar-width-x 40
        sr-speedbar-auto-refresh nil
        sr-speedbar-skip-other-window-p t
        sr-speedbar-right-side nil)

  ;; Refresh the speedbar when relevant hooks are run.
  (defvar graphene-speedbar-refresh-hooks)
  (defvar graphene-speedbar-refresh-hooks-added nil
    "Whether hooks have been added to refresh speedbar.")

  (add-hook 'speedbar-mode-hook
            (when (not graphene-speedbar-refresh-hooks-added)
              (lambda ()
                (mapc (lambda (hook)
                        (add-hook hook 'speedbar-refresh))
                      graphene-speedbar-refresh-hooks)
                (setq graphene-speedbar-refresh-hooks-added t))))

  ;; More familiar keymap settings.
  (add-hook 'speedbar-reconfigure-keymaps-hook
            '(lambda ()
               (define-key speedbar-mode-map [S-up] 'speedbar-up-directory)
               (define-key speedbar-mode-map [right] 'speedbar-flush-expand-line)
               (define-key speedbar-mode-map [left] 'speedbar-contract-line)))

  ;; Highlight the current line
  (add-hook 'speedbar-mode-hook '(lambda () (hl-line-mode 1)))

  ;; Pin and unpin the speedbar
  (defvar graphene-speedbar-pinned-directory)

  (defadvice speedbar-update-directory-contents
    (around graphene-speedbar-pin-directory activate disable)
    "Pin the speedbar to the directory set in graphene-speedbar-pinned-directory."
    (let ((default-directory graphene-speedbar-pinned-directory))
      ad-do-it))

  (defadvice speedbar-dir-follow
    (around graphene-speedbar-prevent-follow activate disable)
    "Prevent speedbar changing directory on button clicks."
    (speedbar-toggle-line-expansion))

  (defadvice speedbar-directory-buttons-follow
    (around graphene-speedbar-prevent-root-follow activate disable)
    "Prevent speedbar changing root directory on button clicks.")

   (defvar graphene-speedbar-pin-advice
     '((speedbar-update-directory-contents around graphene-speedbar-pin-directory)
       (speedbar-dir-follow around graphene-speedbar-prevent-follow)
       (speedbar-directory-buttons-follow around graphene-speedbar-prevent-root-follow))
     "Advice to be enabled and disabled on graphene-[un]-pin-speedbar.")

  (defun graphene-speedbar-pin-advice-activate ()
    "Activate the advice applied to speedbar functions in order to pin it to a directory."
    (mapc 'ad-activate (mapcar 'car graphene-speedbar-pin-advice)))

  (defun graphene-pin-speedbar (directory)
    "Prevent the speedbar from changing the displayed root directory."
    (setq graphene-speedbar-pinned-directory directory)
    (mapc (lambda (ls) (apply 'ad-enable-advice ls)) graphene-speedbar-pin-advice)
    (graphene-speedbar-pin-advice-activate))

  (defun graphene-unpin-speedbar ()
    "Allow the speedbar to change the displayed root directory."
    (mapc (lambda (ls) (apply 'ad-disable-advice ls)) graphene-speedbar-pin-advice)
    (graphene-speedbar-pin-advice-activate))

  ;; Always use the last selected window for loading files from speedbar.
  (defvar last-selected-window
    (if (not (eq (selected-window) sr-speedbar-window))
        (selected-window)
      (other-window 1)))

  (defadvice select-window (after remember-selected-window activate)
    "Remember the last selected window."
    (unless (or (eq (selected-window) sr-speedbar-window) (not (window-live-p (selected-window))))
      (setq last-selected-window (selected-window))))

  (defun sr-speedbar-before-visiting-file-hook ()
    "Function that hooks `speedbar-before-visiting-file-hook'."
    (select-window last-selected-window))

  (defun sr-speedbar-before-visiting-tag-hook ()
    "Function that hooks `speedbar-before-visiting-tag-hook'."
    (select-window last-selected-window))

  (defun sr-speedbar-visiting-file-hook ()
    "Function that hooks `speedbar-visiting-file-hook'."
    (select-window last-selected-window))

  (defun sr-speedbar-visiting-tag-hook ()
    "Function that hooks `speedbar-visiting-tag-hook'."
    (select-window last-selected-window))
#+END_SRC

**** graphene-projects.el

     Some setup is necessary to use graphene-projects.el. I've
     previously required in project-persist, and then I define
     =graphene-speedbar-auto= and =graphene-project-pin-speedbar=
     (which are normally defined in graphene.el).

#+BEGIN_SRC emacs-lisp
  (defvar graphene-speedbar-auto t
    "Whether graphene should open sr-speedbar when a project is loaded.")

  (defvar graphene-project-pin-speedbar t
    "Pin the speedbar directory when opening a project.")
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (defun graphene-set-project-root (dir)
    "Change the default directory and update speedbar if used."
    (setq default-directory dir)
    (when graphene-speedbar-auto
      (sr-speedbar-open)
      (speedbar-update-contents)
      (when graphene-project-pin-speedbar
        (graphene-pin-speedbar dir))))

  (defun graphene-load-project-desktop ()
    "Load the project's desktop if available."
    (ignore-errors
      (setq default-directory project-persist-current-project-settings-dir)
      (message (format "Loading project desktop from %s" default-directory))
      (desktop-read project-persist-current-project-settings-dir)))

   ;; Kill all file-based buffers and unpin the speedbar before opening a project.
  (add-hook 'project-persist-before-load-hook
            (lambda ()
              (graphene-unpin-speedbar)
              (kill-all-buffers)))

   ;; Kill all file-based buffers and unpin the speedbar after closing a project.
  (add-hook 'project-persist-after-close-hook
            (lambda ()
              (kill-all-buffers)
              (graphene-unpin-speedbar)))

  ;; Set the project root directory, load the project desktop and update speedbar.
  (add-hook 'project-persist-after-load-hook
            (lambda ()
              (graphene-load-project-desktop)
              (graphene-set-project-root project-persist-current-project-root-dir)))

  ;; Save the project desktop.
  (add-hook 'project-persist-after-save-hook
            (lambda ()
              (message (format "Saving project desktop in %s" project-persist-current-project-settings-dir))
              (desktop-save project-persist-current-project-settings-dir)))

  ;; http://www.emacswiki.org/DeskTop#toc4: Overriding stale desktop locks
  ;;; desktop-override-stale-locks.el begins here
  (defun emacs-process-p (pid)
    "If pid is the process ID of an emacs process, return t, else nil.
  Also returns nil if pid is nil."
    (when pid
      (let ((attributes (process-attributes pid)) (cmd))
        (dolist (attr attributes)
          (if (string= "comm" (car attr))
              (setq cmd (cdr attr))))
        (if (and cmd (or (string= "emacs" cmd) (string= "emacs.exe" cmd))) t))))

  (defadvice desktop-owner (after pry-from-cold-dead-hands activate)
    "Don't allow dead emacsen to own the desktop file."
    (when (not (emacs-process-p ad-return-value))
      (setq ad-return-value nil)))
  ;;; desktop-override-stale-locks.el ends here
#+END_SRC

** Ruby Packages

  I really enjoy writing ruby.

  At a high level, my MacOS has RVM installed from http://rvm.io.

  Then, my emacs uses a package named rvm that understands how
  http://rvm.io works, and can direct emacs to use any of the various
  rubies that rvm provides.

  I explicitly use the default ruby from RVM, but Emacs also updates
  the ruby I'm using each time I start editing a file in ruby-mode. I
  think this works by looking at the location of the file I'm editing,
  looking "up" to find the associated .rvmrc or .ruby-version, and
  then activating it.

  With all of that said, my main flow is to run rspec and cucumber
  from within emacs. This capability is provided by feature-mode and
  rspec-mode.

  The main key bindings I use are:

    + =C-c , v=

      Run rspec or cucumber against the file I'm editing

    + =C-c , s=

      Run rspec or cucumber against the single line of the spec or
      feature I'm editing.

*** rvm

#+begin_src emacs-lisp
  (sacha/package-install 'rvm)
#+end_src

  For emacs, on a MacOS, I believe the following configures my setup
  so that I'll use the default ruby provided by RVM when I need ruby.

#+begin_src emacs-lisp
  (rvm-use-default)
#+end_src

  I was reading a [[http://devblog.avdi.org/2011/10/11/rvm-el-and-inf-ruby-emacs-reboot-14/][blog post by Avdi Grimm about how he was using RVM]]
  the other day, and that's where I picked up the following helpful
  snippet that works with the emacs rvm subsystem to activate the
  correct version of ruby each time you open a ruby-based file:

#+begin_src emacs-lisp
  (add-hook 'ruby-mode-hook
            (lambda () (rvm-activate-corresponding-ruby)))
#+end_src

*** feature-mode

  I don't often write Gherkin at work, but I do try to use Cucumber
  whenever I get the chance on side projects. So far I've been using
  this mode mainly for syntax highlighting.

#+begin_src emacs-lisp
  (sacha/package-install 'feature-mode)
#+end_src

*** rspec-mode

  I *love* rspec.

#+begin_src emacs-lisp
  (sacha/package-install 'rspec-mode)
#+end_src

  I also have been using ZSH, and when I was getting rspec-mode up and
  running a few months ago, I ran into trouble. Thankfully, the author
  of rspec mode had [[https://github.com/pezra/rspec-mode][a solution for using rspec mode with ZSH]].

#+begin_src emacs-lisp
  (defadvice rspec-compile (around rspec-compile-around)
    "Use BASH shell for running the specs because of ZSH issues."
    (let ((shell-file-name "/bin/bash"))
      ad-do-it))
  (ad-activate 'rspec-compile)
#+end_src

*** ruby-mode

  For now, the main thing I do is turn on ruby-mode when I'm
  editing well known file types:

#+begin_src emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.rake$" . ruby-mode))
  (add-to-list 'auto-mode-alist '("\\.gemspec$" . ruby-mode))
  (add-to-list 'auto-mode-alist '("\\.ru$" . ruby-mode))
  (add-to-list 'auto-mode-alist '("Rakefile$" . ruby-mode))
  (add-to-list 'auto-mode-alist '("Gemfile$" . ruby-mode))
  (add-to-list 'auto-mode-alist '("Capfile$" . ruby-mode))
  (add-to-list 'auto-mode-alist '("Vagrantfile$" . ruby-mode))
  (add-to-list 'auto-mode-alist '("\\.thor$" . ruby-mode))
  (add-to-list 'auto-mode-alist '("Thorfile$" . ruby-mode))
  (add-to-list 'auto-mode-alist '("Guardfile" . ruby-mode))
#+end_src

  Also, when you press return in ruby, go to a new line and indent
  rather than just going to a new line.

#+BEGIN_SRC emacs-lisp
  (add-hook 'ruby-mode-hook
            (lambda ()
              (define-key (current-local-map) [remap newline] 'reindent-then-newline-and-indent)))
#+END_SRC

*** ruby-electric

    This minor mode automatically inserts a right brace when you
    enter a left brace, or an "end" when you define a def.

#+begin_src emacs-lisp
  (sacha/package-install 'ruby-electric)
#+end_src

** Magit

   Everyone *loves* magit.

   I like to think "C-x m"agit.

#+begin_src emacs-lisp
  (global-set-key (kbd "C-x m") 'magit-status)
#+end_src

   Beyond cosmetics, here are two great blog posts about magit: [[http://whattheemacsd.com/setup-magit.el-01.html][Setup
   Magit #1]] and [[http://whattheemacsd.com/setup-magit.el-02.html][Setup Magit #2]].  The main points are:

   + Give Magit full screen when you start it.

   + Setup Magit so that pressing "q" gets rid of full screen.

   + Setup Magit so that pressing "W" toggles paying attention to
     whitespace.

   I happen to have =emacsclient= installed in two places, one at
   =/usr/bin= and another at =/usr/local/bin=. The one at =/usr/bin=
   cannot find my emacs server and this causes Magit to freeze
   whenever I try to commit. This is why I explicitly set
   =magit-emacsclient-executable=.

#+begin_src emacs-lisp
  (sacha/package-install 'magit)

  (require 'magit)

  (defadvice magit-status (around magit-fullscreen activate)
    (window-configuration-to-register :magit-fullscreen)
    ad-do-it
    (delete-other-windows))

  (defun magit-quit-session ()
    "Restores the previous window configuration and kills the magit buffer"
    (interactive)
    (kill-buffer)
    (jump-to-register :magit-fullscreen))

  (define-key magit-status-mode-map (kbd "q") 'magit-quit-session)

  (defun magit-toggle-whitespace ()
    (interactive)
    (if (member "-w" magit-diff-options)
        (magit-dont-ignore-whitespace)
      (magit-ignore-whitespace)))

  (defun magit-ignore-whitespace ()
    (interactive)
    (add-to-list 'magit-diff-options "-w")
    (magit-refresh))

  (defun magit-dont-ignore-whitespace ()
    (interactive)
    (setq magit-diff-options (remove "-w" magit-diff-options))
    (magit-refresh))

  (define-key magit-status-mode-map (kbd "W") 'magit-toggle-whitespace)

  (setq magit-emacsclient-executable "/usr/local/bin/emacsclient")
#+end_src

** yasnippet

  My favorite snippet to use is =dbg=, which I found in Jim Weirich's
  emacs setup [[https://github.com/jimweirich/emacs-setup/blob/master/snippets/text-mode/ruby-mode/dbg][here]].

#+begin_src emacs-lisp
  (sacha/package-install 'yasnippet)
  (require 'yasnippet)
  (setq yas-snippet-dirs (concat jedcn-es/dir "/snippets"))
#+end_src

  When I was setting up yasnippet, I saw the following in the official
  documentation:

#+begin_src emacs-lisp
  (yas-global-mode 1)
#+end_src

** org-mode

  OrgMode is a wonderful thing.

** Key Bindsings

   [[http://orgmode.org/manual/Activation.html#Activation][Org-mode documentation]] suggests that some functions be globally
   bound, and I follow their defaults:

#+begin_src emacs-lisp
  (global-set-key "\C-ca" 'org-agenda)
  (global-set-key "\C-cl" 'org-store-link)
  (global-set-key "\C-cc" 'org-capture)
  (global-set-key "\C-cb" 'org-iswitchb)
#+end_src

*** Defaults

  When I open a .org file, I like to see all of the headlines but
  none of the text:

#+begin_src emacs-lisp
  (setq org-startup-folded 'content)
#+end_src

  Hiding the stars looks cleaner to me:

#+begin_src emacs-lisp
  (setq org-hide-leading-stars 'hidestars)
#+end_src

*** Recording Timestamps

    This setting makes it so that a timestamp is recorded whenever you
    mark a task as done. [[http://orgmode.org/manual/Closing-items.html#Closing-items][Manual entry]].

#+begin_src emacs-lisp
  (setq org-log-done 'time)
#+end_src

*** Clock

    These settings are necessary to clock history across emacs
    sessions according to [[http://orgmode.org/manual/Clocking-work-time.html][this documentation]].

#+begin_src emacs-lisp
  (setq org-clock-persist 'history)
  (org-clock-persistence-insinuate)
#+end_src

*** Diary

    Including the "diary" makes it so that your agenda has official
    holidays in it.

#+begin_src emacs-lisp
  (setq org-agenda-include-diary t)
#+end_src

*** Code Blocks

  These emacs configuration files (.org, .el) use org's "code blocks"
  extensively, and the following has Emacs pay attention to the type
  of code within the blocks.

#+begin_src emacs-lisp
  (setq org-src-fontify-natively t)
#+end_src

**** Editing Code Blocks

  With your cursor over one of these code blocks you can type C-c '
  and a new buffer will open for editing just that content.

**** Executing Code Blocks

  With your cursor over one of these code blocks you can type C-c C-c
  and, if the code block is one of the languages that has been
  configured to be run, the block will be executed and the results
  printed nearby.

  By default, only emacs-lisp is configured to be executed.  The
  following block makes it so that ruby and shell scripts are too.

  Here's the documentation for this: [[http://orgmode.org/worg/org-contrib/babel/languages.html][babel/languages]].

#+begin_src emacs-lisp
    (org-babel-do-load-languages
     'org-babel-load-languages
     '((emacs-lisp . t)
       (ruby . t)
       (sh . t)))
#+end_src
*** Agenda, Tasks

    I will plan on keeping .org files underneath =~/notes/org=.

#+begin_src emacs-lisp
  (setq org-agenda-files '("~/notes/org"))
#+end_src

** expand-region

   The functionality from =expand-region= is most easily described by
   watching the excellent emacsrocks.com [[http://emacsrocks.com/e09.html][Introductory Video]]. The
   project is hosted on [[https://github.com/magnars/expand-region.el][github]], and I use a standard setup for it,
   which means that you get things started by pressing =C-==.

#+begin_src emacs-lisp
  (sacha/package-install 'expand-region)
  (require 'expand-region)
  (global-set-key (kbd "C-=") 'er/expand-region)
#+end_src
