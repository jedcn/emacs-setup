#+TITLE: Emacs Configuration
#+OPTIONS: toc:2 h:4

* Overview

  I use a simple mechanism for breaking down a single emacs
  configuration across several component files. Any one of these
  component files is written in a format that enables that file to
  simultaneously be more than one thing. Each file surely contains
  elisp that is used to configure emacs, but that same file also
  contains a prose explanation behind the motivation and impact of the
  associated elisp. The same mechanism combines these component pieces
  to form an overall configuration, ultimately within a single file an
  in pure elisp, that emacs is capable of interpreting. In the end,
  the elisp from each file provides a discrete section of the total,
  generated configuration, just as the prose explanation from each
  file comes to represent a section within this document.

  The value of this mechanism draws from the belief that complexity is
  reduced when each file can bear a single responsibility for
  describing one smaller part of a large configuration. This follows
  from the similar expectation that any one chapter within a larger
  document can rightly be expected to describe a self-contained idea.

  The notion of first creating a prose explanation of how "code" works
  and then embedding that same code within that explanation is known
  as [[http://en.wikipedia.org/wiki/Literate_programming][Literate Programming]]. This document describes two such systems.
  The first, and larger of the two, is a literately programmed emacs
  configuration. The second is a description of how literate
  programming is achieved within emacs and then meaningfully used to
  configure emacs.

** Background: Literate Programming in Emacs

   Emacs provides support for literate programming most directly
   through [[http://orgmode.org/][org-mode]], and, within org-mode, [[http://orgmode.org/worg/org-contrib/babel/][babel]]. When practicing
   literate programming in this style, you author org-mode documents
   as normal and you additionally embed source code within these
   documents. Org-mode gives you strong support for authoring a
   document of any type: you can export to various formats, structure
   documents with semantic headings, generate a table of contents,
   enjoy hyperlink syntax, and more. In addition to basic org-mode
   functionality, babel then allows you to include source code within
   these documents. Source code in this context enjoys the same
   support that emacs provides for normal editing. You can choose any
   single language or a mix of languages and you work in the mode of
   the language.

   Embedded source code and its easy extraction is the foundation that
   enables literate programming. Briefly, as you consider programming
   "a thing," you are given all of the tools you need to write a
   stand-alone document about that "thing." You are free to layout and
   follow a narrative that you see fit. This document is my prose
   explanation of my emacs configuration.

** An Emacs Configuration

   [[http://www.gnu.org/software/emacs/manual/html_node/emacs/Init-File.html][When Emacs is started, it normally tries to load a Lisp program
   from an initialization file, or init file for short.]] The mechanism
   I use for managing my configuration is centered around two elisp
   files. A smaller initialization file, =init.el=, lives in
   =~/.emacs.d=, a location that is well known to emacs and this file
   is read on start-up. =init.el= presumes that it will be able to
   load a much larger elisp file located at
   =~/emacs.d/emacs-setup/emacs-setup.el=.

   These two files, =init.el= and =emacs-setup.el=, are extracted from
   source code blocks within .org files using babel. Appendix A
   contains =init.el= in its entirety. The contents of =emac-setup.el=
   are spread across the remainder of the .org files and can be
   constructed by concatenating the extract results of all files.

   In summary, I use Org-mode and .org files to serve two purposes:

    + .org files contain documentation of my configuration. This
      documentation can be viewed on Github or translated into another
      format such as LaTeX or HTML.

    + .org files contain embedded elisp behind the same configuration.
      Babel, a feature of Org-mode, can parse a .org file and extract
      the associated elisp.

   Appendix A details how I install and setup emacs. It also contains
   information about how =init.el= and the start up process works.
   Appendix B defines a process that is capable of creating
   =emacs-setup.el= from distinct .org files.

   When it comes to elisp, functions and variables associated with my
   emacs setup will begin with =jedcn-es=. The first variable we
   define sets the expecation that the directory =emacs-setup/= can be
   placed (or linked to) underneath =~/.emacs.d=:

#+begin_src emacs-lisp
  (setq jedcn-es/dir (concat
                      user-emacs-directory
                      "emacs-setup"))
#+end_src
* General

** Package Repository

   Extensions for emacs are known as "packages," and emacs has a built
   in package management system. Emacs lisp packages are stored in
   archives (elpas) and, initially, emacs knows about a single such
   archive: http://elpa.gnu.org. This archive has approximately 50
   packages.  However, there are additional elpas out there, and I
   have had good luck finding up-to-date packages in
   http://melpa.milkbox.net/.

   That said, each time I open up emacs I make sure that the package
   management system is initialized before I configure it to use
   melpa:

#+begin_src emacs-lisp
  (package-initialize)

  (add-to-list 'package-archives
               '("melpa" . "http://melpa.milkbox.net/packages/") t)
#+end_src

   My observation is that packages cannot be installed until a
   repository is contacted, at least once, and an overview of the
   contents are downloaded and cached locally.

   The following elisp will run =package-list-packages= if
   =~/.emacs.d/elpa= does not exist, and is rooted in the belief that
   the first time you run =package-list-packages= the contents of the
   archive are cached within =~/.emacs.d/elpa=.

#+begin_src emacs-lisp
  (unless
      (file-directory-p "~/.emacs.d/elpa")
    (package-list-packages))
#+end_src

   I am interested in ensuring that the elpa cache has been created so
   that I can programatically install packages. I first read about
   this in Sacha Chua's excellent blog post on her configuration:
   [[http://sachachua.com/blog/2012/06/literate-programming-emacs-configuration-file/][Literate programming and my Emacs configuration file]]. She defines a
   function (copied below) that will install the package if it is not
   present:

#+begin_src emacs-lisp
  (defun sacha/package-install (package &optional repository)
    "Install PACKAGE if it has not yet been installed.
  If REPOSITORY is specified, use that."
    (unless (package-installed-p package)
      (let ((package-archives (if repository
                                  (list (assoc repository package-archives))
                                package-archives)))
      (package-install package))))
#+end_src

   In combination, these facilities are the foundation of my package
   management strategy: initialize the subsystem, configure the
   repositories, and then define a means to programatically install
   missing packages. Doing this early on in my initialization process
   means that code which follows can state, "I expect to have package
   XYZ," by saying, =(sacha/package-install "XYZ")= and then presume
   that XYZ is present.

** PATH

   Emacs can run shell commands on your behalf. When it does this, it
   needs to know about the equivalent of your PATH so it can find
   commands.

   I am not sure how this works. There is something that is an
   environment variabled named =PATH= that is reachable via =(getenv
   "PATH")= and there is something else that is a elisp variable named
   =exec-path=.

   Rather than interact with my shell and have Emacs learn values from
   a =$PATH= proper, I am explicit about setting both:

#+begin_src emacs-lisp
  (setq jedcn-env-path "/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin:/usr/texbin:/usr/local/share/npm/bin")

  (defun jedcn-sync-env-path-and-exec-path (desired-path)
    "Sets exec-path and env 'PATH' based on DESIRED-PATH"
    (setenv "PATH" desired-path)
    (setq exec-path (split-string desired-path ":")))

  (jedcn-sync-env-path-and-exec-path jedcn-env-path)
#+end_src
** Shell

   The following gives us a "login" shell. Without being quite sure
   what that means, I know that when this is in place my shell init
   files are run, my prompt looks normal, etc.

#+BEGIN_SRC emacs-lisp
  (setq explicit-bash-args '("--noediting" "--login"))
#+END_SRC

** UTF-8

  I picked this up from Magnars in his [[https://github.com/magnars/.emacs.d/blob/master/sane-defaults.el][sane-defaults.el]].

#+begin_src emacs-lisp
    (setq locale-coding-system 'utf-8)
    (set-terminal-coding-system 'utf-8)
    (set-keyboard-coding-system 'utf-8)
    (set-selection-coding-system 'utf-8)
    (prefer-coding-system 'utf-8)
    (set-language-environment 'utf-8)
    (set-default-coding-systems 'utf-8)
#+end_src

** Start Server

   Emacs is often run for hours (or days, or weeks) at a time. One of
   the benefits of such a long-lived process is that you can build a
   small tool, like =emacsclient= that can connect to a running emacs
   and request that something be edited. For example, you can tell git
   that it should use =emacsclient= whenever it needs to edit
   something:

#+begin_src sh :tangle no
  git config --global core.editor /usr/local/bin/emacsclient
#+end_src

   That said, here's the elisp that starts up an emacs server if it
   is needed:

#+begin_src emacs-lisp
  (require 'server)
  (if (server-running-p)
      (message "Server is running")
    (progn
      (message "Starting server")
      (server-start)))
#+end_src

** Save Place

  I got this one from Magnars: [[http://whattheemacsd.com/init.el-03.html][init.el-03]].

#+begin_src emacs-lisp
  (require 'saveplace)
  (setq-default save-place t)
  (setq save-place-file (expand-file-name ".places" user-emacs-directory))
#+end_src
** Appearance

*** Color Theme

#+begin_src emacs-lisp
  (sacha/package-install 'zenburn-theme)
  (sacha/package-install 'base16-theme)
  (load-theme 'zenburn t)
#+end_src

*** Font

    I like a bigger font (say, 18) and I vary between "Monaco-18" or
    "Menlo-18".

#+begin_src emacs-lisp
  (set-face-attribute 'default nil :font "Menlo-18")
#+end_src

*** Mode Line

#+BEGIN_SRC emacs-lisp
  (sacha/package-install 'powerline)
  (require 'powerline)
  (powerline-center-theme)
#+END_SRC

** Memory

   I believe that Emacs will initiate Garbage Collection every time
   the =gc-cons-threshold= is allocated. That's less than 1MB. I've
   got 16GB, so I'm flush with memory if it speeds up my Emacs.

   This comes from Lewang's [[https://github.com/lewang/flx][documentation on flx]].

#+BEGIN_SRC emacs-lisp
  (setq gc-cons-threshold 20000000)
#+END_SRC
* Personal Information

#+begin_src emacs-lisp
  (setq user-full-name "Jed Northridge"
        user-mail-address "northridge@gmail.com")
#+end_src
* Key Bindings

  My main inspiration for keybindings have come from [[https://github.com/technomancy/emacs-starter-kit/blob/v2/modules/starter-kit-bindings.el][ESK]] and from
  [[https://github.com/magnars/.emacs.d/blob/master/key-bindings.el][Magnars]].

  If a particular mode has a global keybinding, then they keybinding
  will be with the mode in modes.org.

** See Occurrences while Searching

   If you are searching for something, and you press =C-o=, you can
   see all of the occurrences of that something within the file. Once
   that *Occur* window comes up, you can press =e= to start
   editing. You can press =C-c C-c= to get out of it.

#+begin_src emacs-lisp
  (define-key isearch-mode-map (kbd "C-o")
    (lambda () (interactive)
      (let ((case-fold-search isearch-case-fold-search))
        (occur (if isearch-regexp isearch-string (regexp-quote isearch-string))))))
#+end_src

** Running Methods

   When it comes to running methods explicitly, I always use C-x C-m.
   I picked this up from Steve Yegge's [[https://sites.google.com/site/steveyegge2/effective-emacs][Effective Emacs]]. He says use
   =execute-extended-command=, but I always use smex.

#+begin_src emacs-lisp
  (global-set-key "\C-x\C-m" 'smex)
#+end_src

** Text Size

   Making text larger or smaller with ease is something I use every
   day, several times a day. This happens most commonly when I am
   showing someone something in emacs (say, pairing or running a
   meeting), but also when I am at home and do not have my glasses.
   These particular keybindings are all about the =+= and the =-=.

#+begin_src emacs-lisp
  (define-key global-map (kbd "C-+") 'text-scale-increase)
  (define-key global-map (kbd "C--") 'text-scale-decrease)
#+end_src

** Goto Line

  The following makes it so that when I press =C-x g= I can expect to
  be prompted to enter a line number to jump to it.

#+begin_src emacs-lisp
  (global-set-key (kbd "C-x g") 'goto-line)
#+end_src

  And the elisp below makes it so that whatever goto-line was bound to
  is now bound to a new function: goto-line-with-feedback.

  In turn, goto-line-with-feedback modifies the buffer you are working
  in to show line numbers but only when you are actively looking to
  pick a number.

  The point of showing line numbers is to give you an idea of where
  you will end up.

  The point of *only* showing them while going to a line is to keep
  the screen free of distractions (line numbers) unless it is helpful.

  This comes from [[http://whattheemacsd.com/key-bindings.el-01.html][this post]] within "what the emacs.d."

#+begin_src emacs-lisp
  (global-set-key [remap goto-line] 'goto-line-with-feedback)

  (defun goto-line-with-feedback ()
    "Show line numbers temporarily, while prompting for the line number input"
    (interactive)
    (unwind-protect
        (progn
          (linum-mode 1)
          (goto-line (read-number "Goto line: ")))
      (linum-mode -1)))
#+end_src

  Finally, from rdallasgray's [[https://github.com/rdallasgray/graphene][Graphene]], sometimes the line numbers
  look weird, so we give them some extra space.

#+BEGIN_SRC emacs-lisp
  (setq linum-format " %4d ")
#+END_SRC

** MacOS's "Command"

   I think keys called 'super' and 'hyper' used to appear on the
   keyboards of fabled 'Lisp Machines,' as described in this ErgoEmacs
   post about [[http://ergoemacs.org/emacs/emacs_hyper_super_keys.html][Super and Hyper Keys]]. I may take advantage of these some
   day, but for now I am happy to have both the 'alt/option' key and
   the 'command' key on my Mac do the same thing: meta.

   Given the default setup of my brew installed emacs, the following
   change makes it so that "command does meta"

   If I am back this way in the future again, I'd like to remind
   myself to consider the following variables: mac-option-modifier,
   mac-command-modifier, and ns-function-modifer.

#+begin_src emacs-lisp
  (setq mac-command-modifier 'meta)
#+end_src

** Movement

   I rely on standard emacs commands to move around, with the
   following enhancements:

*** Using shift makes standard movement 5x faster

    This comes from Magnars in this [[http://whattheemacsd.com/key-bindings.el-02.html][post of whattheemacsd.com]].

#+begin_src emacs-lisp
  (global-set-key (kbd "C-S-n")
                  (lambda ()
                    (interactive)
                    (ignore-errors (next-line 5))))

  (global-set-key (kbd "C-S-p")
                  (lambda ()
                    (interactive)
                    (ignore-errors (previous-line 5))))

  (global-set-key (kbd "C-S-f")
                  (lambda ()
                    (interactive)
                    (ignore-errors (forward-char 5))))

  (global-set-key (kbd "C-S-b")
                  (lambda ()
                    (interactive)
                    (ignore-errors (backward-char 5))))
#+end_src

*** Move current line up or down

    This matches what Magnars says in [[http://whattheemacsd.com/editing-defuns.el-02.html][this post]], except I also use
    META.

#+begin_src emacs-lisp
  (defun move-line-down ()
    (interactive)
    (let ((col (current-column)))
      (save-excursion
        (forward-line)
        (transpose-lines 1))
      (forward-line)
      (move-to-column col)))

  (defun move-line-up ()
    (interactive)
    (let ((col (current-column)))
      (save-excursion
        (forward-line)
        (transpose-lines -1))
      (move-to-column col)))
  (global-set-key (kbd "<C-M-S-down>") 'move-line-down)
  (global-set-key (kbd "<C-M-S-up>") 'move-line-up)
#+end_src
* Behaviors

  ...

  be·hav·ior
  /biˈhāvyər/
  Noun

  + The way in which one acts or conducts oneself, esp. toward others:
    "his insulting behavior towards me".

  + The way in which an animal or person acts in response to a
    particular situation or stimulus: "the feeding behavior of
    predators".

  ...

** Miscellaneous

   Do not "ding" all of the time, and instead flash the screen. Do not
   show the Emacs "splash" screen.

#+begin_src emacs-lisp
  (setq visible-bell t
        inhibit-startup-message t)
#+end_src

** Whitespace Cleanup

   The following creates a function that cleans up whitespace, and
   then adds a hook that makes this happen each time you save. It
   comes from a post within "what the emacs.d," specifically titled
   [[http://whattheemacsd.com/buffer-defuns.el-01.html][buffer defuns]].

#+begin_src emacs-lisp
  (defun cleanup-buffer-safe ()
    "Perform a bunch of safe operations on the whitespace content of a buffer."
    (interactive)
    (untabify (point-min) (point-max))
    (delete-trailing-whitespace)
    (set-buffer-file-coding-system 'utf-8))

  (add-hook 'before-save-hook 'cleanup-buffer-safe)
#+end_src

** Yes or No?

   Emacs often asks you to type "yes or no" to proceed. As an example,
   consider when you are in magit, and you press "k" to kill off a
   hunk. I am happy to have a confirmation before something is
   deleted, but I prefer to just press "y" instead of "y-e-s-<RETURN>"

#+begin_src emacs-lisp
  (defalias 'yes-or-no-p 'y-or-n-p)
#+end_src

** Autofill

   By observation alone, =auto-fill-mode= makes it so that words wrap
   around the screen by inserting a new line once you go past a
   certain spot. I want to auto-fill if I am working on text. When I
   am programming, I only want to auto-fill if I am writing a comment.

   Both of these come from technomancy in v2 of the [[https://github.com/technomancy/emacs-starter-kit][emacs-starter-kit]].

#+begin_src emacs-lisp
  (defun esk-local-comment-auto-fill ()
    (set (make-local-variable 'comment-auto-fill-only-comments) t)
    (auto-fill-mode t))
  (add-hook 'prog-mode-hook 'esk-local-comment-auto-fill)

  (add-hook 'text-mode-hook 'turn-on-auto-fill)
#+end_src

** Display Line + Column Numbers

   Show line and column numbers all the time.

#+begin_src emacs-lisp
  (setq line-number-mode t)
  (setq column-number-mode t)
#+end_src

** Highlight Current Line when Programming

   Highlight the current line. This comes from technomancy in v2 of
   the [[https://github.com/technomancy/emacs-starter-kit][emacs-starter-kit]].

#+begin_src emacs-lisp
  (defun esk-turn-on-hl-line-mode ()
    (when (> (display-color-cells) 8)
      (hl-line-mode t)))

  (add-hook 'prog-mode-hook 'esk-turn-on-hl-line-mode)
#+end_src

** Use λ instead of lambda

   If you see "lambda" replace it with a λ. This comes from
   technomancy in v2 of the [[https://github.com/technomancy/emacs-starter-kit][emacs-starter-kit]].

#+begin_src emacs-lisp
  (defun esk-pretty-lambdas ()
    (font-lock-add-keywords
     nil `(("(?\\(lambda\\>\\)"
            (0 (progn (compose-region (match-beginning 1) (match-end 1)
                                      ,(make-char 'greek-iso8859-7 107))
                      nil))))))

  (add-hook 'prog-mode-hook 'esk-pretty-lambdas)
#+end_src
* Major Modes, Minor Modes, and Packages

  Major and Minor Modes are one avenue that bring significant
  functionality into Emacs.

  The difference between Major and Minor Mode is that only a single
  Major mode may be in use at a time. A Major Mode typically defines
  the type of document that you are creating, while a Minor Mode
  provides conveniences that may be helpful with many types of files.

  =org-mode=, =text-mode=, and =ruby-mode= are all major modes. They
  are used to create files of a certain type (org, text, and
  ruby). They define keybindings. They define how documents should be
  displayed and interacted with.

  =auto-fill= is a minor mode. It helps you "toggle automatic line
  breaking," which is helpful in =org-mode=, but also in =text-mode=
  and =ruby-mode=.

  Finally, functionality can be delivered independently from a
  mode. For example, a library like =better-defaults= can provide
  elisp code that configures emacs regardless of whether or not you
  ever make use of =org-mode= (a major mode) or =auto-fill-mode= (a
  minor mode).

  This section describes the core modes that I use, and how they are
  configured.

** Getting Code

   My main method for retrieving and installing source code is via the
   bare package management system. When I'd like to try something out,
   I type =M-x package-list-packages= and look around. As you move
   throughout the resulting buffer, if you see something you like you
   can press =i= and the package on the same line as your cursor will
   be marked for an upcoming installation. When you are ready, press
   'x' to install each package that has been marked in this way.

   If I like a package, I'll revisit this file (=modes.org=) and
   formally add the new package so that it's downloaded when I next
   rebuild from scratch. I'll also add mode configuration elisp and
   notes about what it helps me achieve.

** Major Modes
*** Magit

    Everyone *loves* magit.

    I like to think "C-x m"agit.

#+begin_src emacs-lisp
  (global-set-key (kbd "C-x m") 'magit-status)
#+end_src

    Here are two great blog posts about magit: [[http://whattheemacsd.com/setup-magit.el-01.html][Setup Magit #1]] and
    [[http://whattheemacsd.com/setup-magit.el-02.html][Setup Magit #2]].  The main points are:

    + Give Magit full screen when you start it.

    + Setup Magit so that pressing "q" gets rid of full screen.

    + Setup Magit so that pressing "W" toggles paying attention to
      whitespace.

    I happen to have =emacsclient= installed in two places, one at
    =/usr/bin= and another at =/usr/local/bin=. The one at =/usr/bin=
    cannot find my emacs server and this causes Magit to freeze
    whenever I try to commit. This is why I explicitly set
    =magit-emacsclient-executable=.

#+begin_src emacs-lisp
  (sacha/package-install 'magit)

  (require 'magit)

  (defadvice magit-status (around magit-fullscreen activate)
    (window-configuration-to-register :magit-fullscreen)
    ad-do-it
    (delete-other-windows))

  (defun magit-quit-session ()
    "Restores the previous window configuration and kills the magit buffer"
    (interactive)
    (kill-buffer)
    (jump-to-register :magit-fullscreen))

  (define-key magit-status-mode-map (kbd "q") 'magit-quit-session)

  (defun magit-toggle-whitespace ()
    (interactive)
    (if (member "-w" magit-diff-options)
        (magit-dont-ignore-whitespace)
      (magit-ignore-whitespace)))

  (defun magit-ignore-whitespace ()
    (interactive)
    (add-to-list 'magit-diff-options "-w")
    (magit-refresh))

  (defun magit-dont-ignore-whitespace ()
    (interactive)
    (setq magit-diff-options (remove "-w" magit-diff-options))
    (magit-refresh))

  (define-key magit-status-mode-map (kbd "W") 'magit-toggle-whitespace)

  (setq magit-emacsclient-executable "/usr/local/bin/emacsclient")
#+end_src

*** org-mode

    OrgMode is a wonderful thing.

**** Key Bindings

     [[http://orgmode.org/manual/Activation.html#Activation][Org-mode documentation]] suggests that some functions be globally
     bound, and I follow their defaults:

#+begin_src emacs-lisp
  (global-set-key "\C-ca" 'org-agenda)
  (global-set-key "\C-cl" 'org-store-link)
  (global-set-key "\C-cc" 'org-capture)
  (global-set-key "\C-cb" 'org-iswitchb)
#+end_src

**** Defaults

     When I open a .org file, I like to see all of the headlines but
     none of the text:

#+begin_src emacs-lisp
  (setq org-startup-folded 'content)
#+end_src

     Hiding the stars looks cleaner to me:

#+begin_src emacs-lisp
  (setq org-hide-leading-stars 'hidestars)
#+end_src

**** Recording Timestamps

     This setting makes it so that a timestamp is recorded whenever
     you mark a task as done. [[http://orgmode.org/manual/Closing-items.html#Closing-items][Manual entry]].

#+begin_src emacs-lisp
  (setq org-log-done 'time)
#+end_src

**** Clock

     These settings are necessary to clock history across emacs
     sessions according to [[http://orgmode.org/manual/Clocking-work-time.html][this documentation]].

#+begin_src emacs-lisp
  (setq org-clock-persist 'history)
  (org-clock-persistence-insinuate)
#+end_src

**** Diary

     Including the "diary" makes it so that your agenda has official
     holidays in it.

#+begin_src emacs-lisp
  (setq org-agenda-include-diary t)
#+end_src

**** Code Blocks

     These emacs configuration files (.org, .el) use org's "code
     blocks" extensively, and the following has Emacs pay attention to
     the type of code within the blocks.

#+begin_src emacs-lisp
  (setq org-src-fontify-natively t)
#+end_src

***** Editing Code Blocks

      With your cursor over one of these code blocks you can type C-c '
      and a new buffer will open for editing just that content.

***** Executing Code Blocks

      With your cursor over one of these code blocks you can type C-c
      C-c and, if the code block is one of the languages that has been
      configured to be run, the block will be executed and the results
      printed nearby.

      By default, only emacs-lisp is configured to be executed.  The
      following block makes it so that ruby and shell scripts are too.

      Here's the documentation for this: [[http://orgmode.org/worg/org-contrib/babel/languages.html][babel/languages]].

#+begin_src emacs-lisp
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((emacs-lisp . t)
     (ruby . t)
     (sh . t)))
#+end_src

**** Agenda, Tasks

     I will plan on keeping .org files underneath =~/notes/org=.

#+begin_src emacs-lisp
  (setq org-agenda-files '("~/notes/org"))
#+end_src

*** markdown-mode

    I write in Markdown all the time, and sometimes I use the
    "compilation" facility of this mode.

    If you do start using the compilation aspect, you'll need a
    command line "markdown" to execute.

    I got markdown with =brew install markdown=.

    My notes indicate that:

    You can change the markdown executable, or read more about the
    mode, here: http://jblevins.org/projects/markdown-mode/

    Also, Highlights:

    + =C-c C-c p=: Run markdown on buffer contents. Open result in
      browser.

    I started using markdown-mode+ recently, and I did so after doing
    a bunch of work to get pandoc installed and working with Emacs.

#+begin_src emacs-lisp
  (sacha/package-install 'markdown-mode)
  (sacha/package-install 'markdown-mode+)
  (add-to-list 'auto-mode-alist '("\\.md$" . markdown-mode))
#+end_src

*** coffee-mode

    I love CoffeeScript, and I love editing CoffeeScript, but I was
    confused by =coffee-mode=. It brings a neat approach for "what
    should happen when you press TAB," but I was thrown off by the
    size of the indents. At first it was defaulting to 8 spaces when I
    wanted 2.

    I got my two space indent from the hook defined below. The same
    hook also sets it up so that pressing "Command C" *compiles* the
    CoffeeScript and displays the resulting JavaScript in a new
    window.

    To get compilation going, I did an =npm install -g coffee=. This
    meant the =coffee= executable is installed at
    =/usr/share/local/npm/bin=. This directory is in my path via
    =jedcn-env-path=.

#+begin_src emacs-lisp
  (sacha/package-install 'coffee-mode)

  (defun jedcn-coffee-custom ()
    "jedcn's coffee-mode-hook"
    (define-key coffee-mode-map [(meta c)] 'coffee-compile-buffer)
    (make-local-variable 'tab-width)
    (set 'tab-width 2))

  (add-hook 'coffee-mode-hook '(lambda () (jedcn-coffee-custom)))
#+end_src

*** haml-mode

#+begin_src emacs-lisp
  (sacha/package-install 'haml-mode)
#+end_src

*** puppet-mode

#+begin_src emacs-lisp
  (sacha/package-install 'puppet-mode)
  (add-to-list 'auto-mode-alist '("\\.pp$" . puppet-mode))
#+end_src

*** slim-mode

#+begin_src emacs-lisp
  (sacha/package-install 'slim-mode)
#+end_src

*** yaml-mode

#+begin_src emacs-lisp
  (sacha/package-install 'yaml-mode)
  (add-to-list 'auto-mode-alist '("\\.yml$" . yaml-mode))
#+end_src

*** scss-mode

#+BEGIN_SRC emacs-lisp
  (sacha/package-install 'scss-mode)
#+END_SRC

*** js-mode

    I love JavaScript.

#+BEGIN_SRC emacs-lisp
  (setq js-indent-level 2)
#+END_SRC

*** feature-mode

  I don't often write Gherkin at work, but I do try to use Cucumber
  whenever I get the chance on side projects. So far I've been using
  this mode mainly for syntax highlighting.

#+begin_src emacs-lisp
  (sacha/package-install 'feature-mode)
#+end_src

*** ruby-mode

    I really enjoy writing ruby.

    At a high level, my MacOS has RVM installed from http://rvm.io.

    Then, my emacs uses a package named rvm that understands how
    http://rvm.io works, and can direct emacs to use any of the
    various rubies that rvm provides.

    I explicitly use the default ruby from RVM, but Emacs also updates
    the ruby I'm using each time I start editing a file in
    ruby-mode. I think this works by looking at the location of the
    file I'm editing, looking "up" to find the associated .rvmrc or
    .ruby-version, and then activating it.

    With all of that said, my main flow is to run rspec and cucumber
    from within emacs. This capability is provided by feature-mode and
    rspec-mode.

    The main key bindings I use are:

    + =C-c , v=

      Run rspec or cucumber against the file I'm editing

    + =C-c , s=

      Run rspec or cucumber against the single line of the spec or
      feature I'm editing.

    For now, the main thing I do is turn on ruby-mode when I'm
    editing well known file types:

#+begin_src emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.rake$" . ruby-mode))
  (add-to-list 'auto-mode-alist '("\\.gemspec$" . ruby-mode))
  (add-to-list 'auto-mode-alist '("\\.ru$" . ruby-mode))
  (add-to-list 'auto-mode-alist '("Rakefile$" . ruby-mode))
  (add-to-list 'auto-mode-alist '("Gemfile$" . ruby-mode))
  (add-to-list 'auto-mode-alist '("Capfile$" . ruby-mode))
  (add-to-list 'auto-mode-alist '("Vagrantfile$" . ruby-mode))
  (add-to-list 'auto-mode-alist '("\\.thor$" . ruby-mode))
  (add-to-list 'auto-mode-alist '("Thorfile$" . ruby-mode))
  (add-to-list 'auto-mode-alist '("Guardfile" . ruby-mode))
#+end_src

    Also, when you press return in ruby, go to a new line and indent
    rather than just going to a new line.

#+BEGIN_SRC emacs-lisp
  (add-hook 'ruby-mode-hook
            (lambda ()
              (define-key (current-local-map) [remap newline] 'reindent-then-newline-and-indent)))
#+END_SRC

** Minor Modes
*** yasnippet

    My favorite snippet to use is =dbg=, which I found in Jim Weirich's
    emacs setup [[https://github.com/jimweirich/emacs-setup/blob/master/snippets/text-mode/ruby-mode/dbg][here]].

#+begin_src emacs-lisp
  (sacha/package-install 'yasnippet)
  (require 'yasnippet)
  (setq yas-snippet-dirs (concat jedcn-es/dir "/snippets"))
#+end_src

    When I was setting up yasnippet, I saw the following in the official
    documentation:

#+begin_src emacs-lisp
  (yas-global-mode 1)
#+end_src

*** smartparens

#+BEGIN_SRC emacs-lisp
  (sacha/package-install 'smartparens)
  (require 'smartparens-config)
  (smartparens-global-mode)
  (show-smartparens-global-mode +1)
#+END_SRC

*** auto-complete

    [[http://cx4a.org/software/auto-complete/][auto-complete]].

#+BEGIN_SRC emacs-lisp
  (sacha/package-install 'auto-complete)
  (sacha/package-install 'ac-dabbrev)
  (require 'auto-complete-config)
  (ac-config-default)
#+END_SRC

*** ace-jump-mode

#+begin_src emacs-lisp
  (sacha/package-install 'ace-jump-mode)
  (require 'ace-jump-mode)
  (define-key global-map (kbd "C-c SPC") 'ace-jump-mode)
#+end_src

*** flycheck

    I've just learned about flycheck, and am experimenting with it
    now.

    In some cases it relies on external tools to check for it. The
    tools that I am presently making use of are:

    - jshint :: via =npm install -g jshint=
    - jsonlint :: via =npm install -g jsonlint=
    - coffeelint :: via =npm install -g coffeelint=

    I make sure these are available to emacs by making sure that the
    location that npm puts stuff (=/usr/local/share/npm/bin=) is in my
    =jedcn-env-path=.

    Nah. This isn't working for me. Too aggressive. Will come back
    another time.

#+BEGIN_SRC emacs-lisp
;;  (sacha/package-install 'flycheck)
;;  (add-hook 'after-init-hook #'global-flycheck-mode)
#+END_SRC

*** rspec-mode

    I *love* rspec.

#+begin_src emacs-lisp
  (sacha/package-install 'rspec-mode)
#+end_src

    I also have been using ZSH, and when I was getting rspec-mode up
    and running a few months ago, I ran into trouble. Thankfully, the
    author of rspec mode had [[https://github.com/pezra/rspec-mode][a solution for using rspec mode with ZSH]].

#+begin_src emacs-lisp
  (defadvice rspec-compile (around rspec-compile-around)
    "Use BASH shell for running the specs because of ZSH issues."
    (let ((shell-file-name "/bin/bash"))
      ad-do-it))
  (ad-activate 'rspec-compile)
#+end_src

** General Package Listing
*** better-defaults

    I started with Emacs Starter Kit, and am following its progression
    from v1 to v2 and, now, v3. In v3 the esk becomes prose only, and
    identifies =better-defaults= as a single package with "universal
    appeal."

#+begin_src emacs-lisp
  (sacha/package-install 'better-defaults)
#+end_src

*** smex

    When you want to run a command (say, via M-x) [[https://github.com/nonsequitur/smex][smex]] provides
    instant feedback by displaying available commands and remembering
    ones you have recently invoked.

    I am using it as the front-end for Ido.

#+begin_src emacs-lisp
  (sacha/package-install 'smex)
  (setq smex-save-file (concat user-emacs-directory ".smex-items"))
  (smex-initialize)
  (global-set-key (kbd "M-x") 'smex)
#+end_src

*** flx-ido

    [[https://github.com/lewang/flx][flx-ido]] is a package written with the idea of bringing the fuzzy
    search of Sublime Text to Emacs.

    It enhances =ido=, and so the configuration below turns on ido,
    turns on flx-ido, uses ido for all buffer/file reading, and
    finally disables ido's style of highlighting. In constrast to
    Ido's highlighting, flx-ido provides insight into which actual
    characters are causing the hits.

#+BEGIN_SRC emacs-lisp
  (sacha/package-install 'flx-ido)
  (require 'flx-ido)
  (ido-mode 1)
  (ido-everywhere 1)
  (flx-ido-mode 1)
  (setq ido-use-faces nil)
#+END_SRC

*** diminish

    In Emacs, the "mode line" shows you information about the active
    major and any active minor modes. In some cases this is helpful
    and in other cases this is just "noise." The diminish library
    allows you to eliminate (or change) contributions that packages
    make to the mode line.

    I found out about it through this [[http://whattheemacsd.com/init.el-04.html][post]]. It lives [[http://www.eskimo.com/~seldon/diminish.el][here]].

    You can see which modes have been diminished with
    =diminished-modes=.

#+BEGIN_SRC emacs-lisp
  (sacha/package-install 'diminish)
  (eval-after-load "yasnippet" '(diminish 'yas-minor-mode))
  (diminish 'auto-fill-function)
#+END_SRC

*** rvm

#+begin_src emacs-lisp
  (sacha/package-install 'rvm)
#+end_src

    For emacs, on a MacOS, I believe the following configures my setup
    so that I'll use the default ruby provided by RVM when I need
    ruby.

#+begin_src emacs-lisp
  (rvm-use-default)
#+end_src

    I was reading a [[http://devblog.avdi.org/2011/10/11/rvm-el-and-inf-ruby-emacs-reboot-14/][blog post by Avdi Grimm about how he was using RVM]]
    the other day, and that's where I picked up the following helpful
    snippet that works with the emacs rvm subsystem to activate the
    correct version of ruby each time you open a ruby-based file:

#+begin_src emacs-lisp
  (add-hook 'ruby-mode-hook
            (lambda () (rvm-activate-corresponding-ruby)))
#+end_src

*** expand-region

    The functionality from =expand-region= is most easily described by
    watching the excellent emacsrocks.com [[http://emacsrocks.com/e09.html][Introductory Video]]. The
    project is hosted on [[https://github.com/magnars/expand-region.el][github]], and I use a standard setup for it,
    which means that you get things started by pressing =C-==.

#+begin_src emacs-lisp
  (sacha/package-install 'expand-region)
  (require 'expand-region)
  (global-set-key (kbd "C-=") 'er/expand-region)
#+end_src

** Project Management

   I use a combination of project-persist and projectile for project
   management in emacs. Persist lets me manage a "list of projects,"
   and I can generate this list from the layout of my file system.

   Once I've got that, Persist lets me open and close projects, and
   Projectile gives me a helpful "find file in project."

*** projectile

#+BEGIN_SRC emacs-lisp
  (sacha/package-install 'projectile)
  (require 'projectile)
#+END_SRC

*** project-persist

    [[https://github.com/rdallasgray/project-persist][project-persist]] is a lightweight means for keeping track of
    projects. Projects have names and a location on your file
    system. Optionally, they can have settings associated with them.

    That said, you can use project-persist to find a project and close
    a project, and project-persist provides hooks into these events.

**** Basic Installation

#+BEGIN_SRC emacs-lisp
  (sacha/package-install 'project-persist)
  (project-persist-mode t)
#+END_SRC

**** File System Integration

     I layout code on my computer in the following manner:

     + ~/c/misc :: Miscellaneous projects live here.
     + ~/c/personal :: Personal projects live here.
     + ~/d :: Code that I don't author, but that I look at
              semi-regularly lives here.

     For example, if I checkout the source for rake on my computer and I
     just scan through it, it lives at =~/d/rake/=. If I am actively
     working on a project named reveal-ck, it lives at
     =~/c/personal/reveal-ck/=.

     I capture these locations in =jedcn/pp-project-roots=.

     The following code scans through these directories and builds
     project-persist entries for each directory that is found. The
     main interactive entry point is =jedcn-pp/rebuild-projects=.

#+BEGIN_SRC emacs-lisp

  (require 'project-persist)

  (setq jedcn/pp-project-roots
        (list (concat (getenv "HOME") "/c/galileo")
              (concat (getenv "HOME") "/c/misc")
              (concat (getenv "HOME") "/c/personal")
              (concat (getenv "HOME") "/d")))

  (defun jedcn/pp-create-projects-under-root (root)
    "Create project-persist projects for directories under root"
    (let* ((dirs (directory-files root))
           (dir (car dirs))
           (ignore-dirs '("." ".." ".DS_Store")))
      (while dirs
        (unless (member dir ignore-dirs)
          (unless (pp/project-exists dir)
            (pp/project-setup (concat root "/" dir "/") dir)))
        (setq dirs (cdr dirs))
        (setq dir (car dirs)))))

  (defun jedcn/pp-create-all-projects (project-roots)
    "Create all project-persist projects based on PROJECT-ROOTS"
    (let* ((project-root (car project-roots)))
      (while project-roots
        (jedcn/pp-create-projects-under-root project-root)
        (setq project-roots (cdr project-roots))
        (setq project-root (car project-roots)))))

  (defun jedcn-pp/rebuild-projects ()
    (interactive)
    (jedcn/pp-create-all-projects jedcn/pp-project-roots))

  (jedcn-pp/rebuild-projects)
#+END_SRC

**** Hooks

     project-persist is intentionally minimal, so, to get something
     out of it you need to register hooks into its main events. These
     revolve around project management.

     It can integrate with projectile via a shared global variable
     named =default-directory=. If project-persist sets this
     variable, then projectile will pick up on it and focus searches
     underneath it.

**** Key Bindings

#+BEGIN_SRC emacs-lisp
  (global-set-key "\M-1"
                  'project-persist-find)

  (global-set-key "\M-2"
                  'projectile-find-file)

  (add-hook 'magit-mode-hook
            (lambda ()
              (define-key magit-mode-map "\M-1"
                'project-persist-find)
              (define-key magit-mode-map "\M-2"
                'projectile-find-file)
              (define-key magit-mode-map "\M-s"
                'sr-speedbar-toggle)))

  (global-set-key (kbd "C->")
                  'increase-window-height)

  (global-set-key (kbd "C-<")
                  'decrease-window-height)

  (global-set-key (kbd "C-,")
                  'decrease-window-width)

  (global-set-key (kbd "C-.")
                  'increase-window-width)

  (global-set-key (kbd "C-c s")
                  'sr-speedbar-select-window)
#+END_SRC
*** graphene

    Graphene is a great package, but there are parts of it I'm not yet
    ready for just yet (autocomplete, smartparens). Consequently, I've
    inlined copies of it here.

**** graphene-helper-functions.el

#+BEGIN_SRC emacs-lisp
  (defun kill-default-buffer ()
    "Kill the currently active buffer -- set to C-x k so that users are not asked which buffer they want to kill."
    (interactive)
    (let (kill-buffer-query-functions) (kill-buffer)))

  (defun kill-buffer-if-file (buf)
    "Kill a buffer only if it is file-based."
    (when (buffer-file-name buf)
      (when (buffer-modified-p buf)
          (when (y-or-n-p (format "Buffer %s is modified - save it?" (buffer-name buf)))
              (save-some-buffers nil buf)))
      (set-buffer-modified-p nil)
      (kill-buffer buf)))

  (defun kill-all-buffers ()
      "Kill all file-based buffers."
      (interactive)
      (mapc (lambda (buf) (kill-buffer-if-file buf))
       (buffer-list)))

  (defun kill-buffer-and-window ()
    "Close the current window and kill the buffer it's visiting."
    (interactive)
    (progn
      (kill-buffer)
      (delete-window)))

  (defun create-new-buffer ()
    "Create a new buffer named *new*[num]."
    (interactive)
    (switch-to-buffer (generate-new-buffer-name "*new*")))

  (defun insert-semicolon-at-end-of-line ()
    "Add a closing semicolon from anywhere in the line."
    (interactive)
    (save-excursion
      (end-of-line)
      (insert ";")))

  (defun comment-current-line-dwim ()
    "Comment or uncomment the current line."
    (interactive)
    (save-excursion
      (push-mark (beginning-of-line) t t)
      (end-of-line)
      (comment-dwim nil)))

  (defun newline-anywhere ()
    "Add a newline from anywhere in the line."
    (interactive)
    (end-of-line)
    (newline-and-indent))

  (defun increase-window-height (&optional arg)
    "Make the window taller by one line. Useful when bound to a repeatable key combination."
    (interactive "p")
    (enlarge-window arg))

  (defun decrease-window-height (&optional arg)
    "Make the window shorter by one line. Useful when bound to a repeatable key combination."
    (interactive "p")
    (enlarge-window (- 0 arg)))

  (defun decrease-window-width (&optional arg)
    "Make the window narrower by one line. Useful when bound to a repeatable key combination."
    (interactive "p")
    (enlarge-window (- 0 arg) t))

  (defun increase-window-width (&optional arg)
    "Make the window shorter by one line. Useful when bound to a repeatable key combination."
    (interactive "p")
    (enlarge-window arg t))

  ;; Create a new instance of emacs
  (when window-system
    (defun new-emacs-instance ()
      (interactive)
      (let ((path-to-emacs
             (locate-file invocation-name
                          (list invocation-directory) exec-suffixes)))
        (call-process path-to-emacs nil 0 nil))))
#+END_SRC

**** graphene-speedbar.el

     Some setup is necessary to use graphene-speedbar.el. I make sure
     I've got sr-speedbar installed and I define
     =graphene-speedbar-refresh-hooks= (which is normally defined in
     graphene.el).

#+BEGIN_SRC emacs-lisp
  (sacha/package-install 'sr-speedbar)
  (require 'sr-speedbar)

  (defvar graphene-speedbar-refresh-hooks '(after-save-hook)
    "List of hooks which on being run will cause speedbar to refresh.")

  (global-set-key (kbd "M-s") 'sr-speedbar-toggle)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (setq speedbar-hide-button-brackets-flag t
        speedbar-show-unknown-files t
        speedbar-smart-directory-expand-flag t
        speedbar-directory-button-trim-method 'trim
        speedbar-use-images nil
        speedbar-indentation-width 2
        speedbar-use-imenu-flag t
        sr-speedbar-width 20
        sr-speedbar-width-x 24
        sr-speedbar-auto-refresh nil
        sr-speedbar-skip-other-window-p t
        sr-speedbar-right-side nil)

  ;; Refresh the speedbar when relevant hooks are run.
  (defvar graphene-speedbar-refresh-hooks)
  (defvar graphene-speedbar-refresh-hooks-added nil
    "Whether hooks have been added to refresh speedbar.")

  (add-hook 'speedbar-mode-hook
            (when (not graphene-speedbar-refresh-hooks-added)
              (lambda ()
                (mapc (lambda (hook)
                        (add-hook hook 'speedbar-refresh))
                      graphene-speedbar-refresh-hooks)
                (setq graphene-speedbar-refresh-hooks-added t))))

  ;; More familiar keymap settings.
  (add-hook 'speedbar-reconfigure-keymaps-hook
            '(lambda ()
               (define-key speedbar-mode-map [S-up] 'speedbar-up-directory)
               (define-key speedbar-mode-map [right] 'speedbar-flush-expand-line)
               (define-key speedbar-mode-map [left] 'speedbar-contract-line)))

  ;; Highlight the current line
  (add-hook 'speedbar-mode-hook '(lambda () (hl-line-mode 1)))

  ;; Pin and unpin the speedbar
  (defvar graphene-speedbar-pinned-directory)

  (defadvice speedbar-update-directory-contents
    (around graphene-speedbar-pin-directory activate disable)
    "Pin the speedbar to the directory set in graphene-speedbar-pinned-directory."
    (let ((default-directory graphene-speedbar-pinned-directory))
      ad-do-it))

  (defadvice speedbar-dir-follow
    (around graphene-speedbar-prevent-follow activate disable)
    "Prevent speedbar changing directory on button clicks."
    (speedbar-toggle-line-expansion))

  (defadvice speedbar-directory-buttons-follow
    (around graphene-speedbar-prevent-root-follow activate disable)
    "Prevent speedbar changing root directory on button clicks.")

   (defvar graphene-speedbar-pin-advice
     '((speedbar-update-directory-contents around graphene-speedbar-pin-directory)
       (speedbar-dir-follow around graphene-speedbar-prevent-follow)
       (speedbar-directory-buttons-follow around graphene-speedbar-prevent-root-follow))
     "Advice to be enabled and disabled on graphene-[un]-pin-speedbar.")

  (defun graphene-speedbar-pin-advice-activate ()
    "Activate the advice applied to speedbar functions in order to pin it to a directory."
    (mapc 'ad-activate (mapcar 'car graphene-speedbar-pin-advice)))

  (defun graphene-pin-speedbar (directory)
    "Prevent the speedbar from changing the displayed root directory."
    (setq graphene-speedbar-pinned-directory directory)
    (mapc (lambda (ls) (apply 'ad-enable-advice ls)) graphene-speedbar-pin-advice)
    (graphene-speedbar-pin-advice-activate))

  (defun graphene-unpin-speedbar ()
    "Allow the speedbar to change the displayed root directory."
    (mapc (lambda (ls) (apply 'ad-disable-advice ls)) graphene-speedbar-pin-advice)
    (graphene-speedbar-pin-advice-activate))

  ;; Always use the last selected window for loading files from speedbar.
  (defvar last-selected-window
    (if (not (eq (selected-window) sr-speedbar-window))
        (selected-window)
      (other-window 1)))

  (defadvice select-window (after remember-selected-window activate)
    "Remember the last selected window."
    (unless (or (eq (selected-window) sr-speedbar-window) (not (window-live-p (selected-window))))
      (setq last-selected-window (selected-window))))

  (defun sr-speedbar-before-visiting-file-hook ()
    "Function that hooks `speedbar-before-visiting-file-hook'."
    (select-window last-selected-window))

  (defun sr-speedbar-before-visiting-tag-hook ()
    "Function that hooks `speedbar-before-visiting-tag-hook'."
    (select-window last-selected-window))

  (defun sr-speedbar-visiting-file-hook ()
    "Function that hooks `speedbar-visiting-file-hook'."
    (select-window last-selected-window))

  (defun sr-speedbar-visiting-tag-hook ()
    "Function that hooks `speedbar-visiting-tag-hook'."
    (select-window last-selected-window))
#+END_SRC

**** graphene-projects.el

     Some setup is necessary to use graphene-projects.el. I've
     previously required in project-persist, and then I define
     =graphene-speedbar-auto= and =graphene-project-pin-speedbar=
     (which are normally defined in graphene.el).

#+BEGIN_SRC emacs-lisp
  (defvar graphene-speedbar-auto t
    "Whether graphene should open sr-speedbar when a project is loaded.")

  (defvar graphene-project-pin-speedbar t
    "Pin the speedbar directory when opening a project.")
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (defun graphene-set-project-root (dir)
    "Change the default directory and update speedbar if used."
    (setq default-directory dir)
    (when graphene-speedbar-auto
      (sr-speedbar-open)
      (speedbar-update-contents)
      (when graphene-project-pin-speedbar
        (graphene-pin-speedbar dir))))

  (defun graphene-load-project-desktop ()
    "Load the project's desktop if available."
    (ignore-errors
      (setq default-directory project-persist-current-project-settings-dir)
      (message (format "Loading project desktop from %s" default-directory))
      (desktop-read project-persist-current-project-settings-dir)))

   ;; Kill all file-based buffers and unpin the speedbar before opening a project.
  (add-hook 'project-persist-before-load-hook
            (lambda ()
              (graphene-unpin-speedbar)
              (kill-all-buffers)))

   ;; Kill all file-based buffers and unpin the speedbar after closing a project.
  (add-hook 'project-persist-after-close-hook
            (lambda ()
              (kill-all-buffers)
              (graphene-unpin-speedbar)))

  ;; Set the project root directory, load the project desktop and update speedbar.
  (add-hook 'project-persist-after-load-hook
            (lambda ()
              (graphene-load-project-desktop)
              (graphene-set-project-root project-persist-current-project-root-dir)))

  ;; Save the project desktop.
  (add-hook 'project-persist-after-save-hook
            (lambda ()
              (message (format "Saving project desktop in %s" project-persist-current-project-settings-dir))
              (desktop-save project-persist-current-project-settings-dir)))

  ;; http://www.emacswiki.org/DeskTop#toc4: Overriding stale desktop locks
  ;;; desktop-override-stale-locks.el begins here
  (defun emacs-process-p (pid)
    "If pid is the process ID of an emacs process, return t, else nil.
  Also returns nil if pid is nil."
    (when pid
      (let ((attributes (process-attributes pid)) (cmd))
        (dolist (attr attributes)
          (if (string= "comm" (car attr))
              (setq cmd (cdr attr))))
        (if (and cmd (or (string= "emacs" cmd) (string= "emacs.exe" cmd))) t))))

  (defadvice desktop-owner (after pry-from-cold-dead-hands activate)
    "Don't allow dead emacsen to own the desktop file."
    (when (not (emacs-process-p ad-return-value))
      (setq ad-return-value nil)))
  ;;; desktop-override-stale-locks.el ends here
#+END_SRC
* Various and Sundry

** Jim Weirich's eval-buffer

   I saw Jim Weirich give a great talk at one of the keynotes of Ruby
   Conf 2012. The way he used buffer evaluation was just awesome!

   His setup (which I think is described below) allows him to
   consistently show you one piece of code and then pair that code up
   with the output that comes from executing it.

   Unlike using an inferior-ruby process, the resulting code output has
   very little noise.

   You can find the [[https://github.com/jimweirich/emacs-setup-esk/blob/master/eval-buffer.el][original code that he wrote right here]].

   The only thing I've changed is the variable
   =jw-eval-buffer-commands= and instead I've created
   =jedcn-eval-buffer-commands= just because I do not have xruby.

#+begin_src emacs-lisp
  (defconst jedcn-eval-buffer-commands
    '(("js" . "/usr/local/bin/node")
      ("rb" . "ruby")
      ("coffee" . "/usr/local/share/npm/bin/coffee")
      ("clj" . "/Users/jim/local/bin/clojure")
      ("py" . "/usr/bin/python")))
#+end_src

#+begin_src emacs-lisp
  (defconst jw-eval-buffer-name "*EVALBUFFER*")

  (defun jw-eval-buffer ()
    "Evaluate the current buffer and display the result in a buffer."
    (interactive)
    (save-buffer)
    (let* ((file-name (buffer-file-name (current-buffer)))
           (file-extension (file-name-extension file-name))
           (buffer-eval-command-pair (assoc file-extension jedcn-eval-buffer-commands)))
      (if buffer-eval-command-pair
          (let ((command (concat (cdr buffer-eval-command-pair) " " file-name)))
            (shell-command-on-region (point-min) (point-max) command jw-eval-buffer-name nil)
            (pop-to-buffer jw-eval-buffer-name)
            (other-window 1)
            (jw-eval-buffer-pretty-up-errors jw-eval-buffer-name)
            (message ".."))
        (message "Unknown buffer type"))))

  (defun jw-eval-buffer-pretty-up-errors (buffer)
    "Fix up the buffer to highlight the error message (if it contains one)."
    (save-excursion
      (set-buffer buffer)
      (goto-char (point-min))
      (let ((pos (search-forward-regexp "\\.rb:[0-9]+:\\(in.+:\\)? +" (point-max) t)))
        (if pos (progn
                  (goto-char pos)
                  (insert-string "\n\n")
                  (end-of-line)
                  (insert-string "\n"))))))

  (defun jw-clear-eval-buffer ()
    (interactive)
    (save-excursion
      (set-buffer jw-eval-buffer-name)
      (kill-region (point-min) (point-max))))

  (defun jw-eval-or-clear-buffer (n)
    (interactive "P")
    (cond ((null n) (jw-eval-buffer))
          (t (jw-clear-eval-buffer))))
#+end_src
* Appendix A: Installation Details

  This appendix covers both how I install Emacs on MacOS and how I get
  up and running with =emacs-setup=.

** Emacs Installation

   On MacOS I install Emacs using [[http://brew.sh/][Homebrew]]. I run the following,
   inspired by this [[http://emacsredux.com/blog/2013/08/21/color-themes-redux/][Emacs Redux post on color themes]]:

#+begin_src sh :tangle no
  brew install emacs --cocoa --srgb
#+end_src

   This takes some time to complete, and when finished I take another
   step to make Emacs appear as one of my Applications:

#+begin_src sh :tangle no
  ln -s /usr/local/Cellar/emacs/24.3/Emacs.app /Applications
#+end_src

   Now I can start emacs by selecting it graphically in the
   Applications area.

** Using =emacs-setup=

   Once I have Emacs 24+ running, I use git to clone my =emacs-setup=
   to my machine, cd into the cloned directory, and source the file
   =install.sh=:

#+begin_src shell-script :tangle no
  git clone https://github.com/jedcn/emacs-setup.git
  cd emacs-setup
  source install.sh
#+end_src

   The contents of the =install.sh= file achieve the following:

   + They allow you to supply a =HOME= and will create an =.emacs.d=
     if needed.

   + They create a link within this =.emacs.d= back to the cloned
     =emacs-setup=.

   + They create a single line of elisp that loads up the composite
     =emacs-setup.el=.

#+begin_src sh :tangle install.sh
  emacs_setup_dir=`pwd`

  echo "Creating $HOME/.emacs.d (if needed)"
  mkdir -p $HOME/.emacs.d

  echo "Creating $HOME/.emacs.d/emacs-setup as link to $emacs_setup_dir"
  ln -s $emacs_setup_dir $HOME/.emacs.d/emacs-setup

  echo "Creating $HOME/.emacs.d/init.el"
  echo '(load (concat user-emacs-directory "emacs-setup/emacs-setup.el"))' >> $HOME/.emacs.d/init.el
#+end_src

   It is important to note that =HOME= can be given a temporary value
   and this lets me test my installation process. I can get a fresh
   copy of =emacs-setup= and clone it into a temporary directory, and
   then I can run the =install.sh= with a temporary value of =HOME=
   like so:

#+begin_src sh :tangle no
  mkdir /tmp/emacs-setup && cd /tmp/emacs-setup
  git clone https://github.com/jedcn/emacs-setup.git .

  mkdir /tmp/emacs-home
  HOME=/tmp/emacs-home source install.sh
  HOME=/tmp/emacs-home /Applications/Emacs.app/Contents/MacOS/Emacs &
#+end_src
* Appendix B: Babel and the Config

  My configuration is stored as several .org files. This is done to
  optimize for editing and the production of documentation (via
  =org-export=). However, emacs does not read these .org files and
  instead it reads a single elisp file, =emacs-setup.el=.

  How is a single elisp file generated from several .org files? The
  .org files are concatenated together in a specific order to create a
  composite .org file named =emacs-setup.org=. This composite file can
  be used to generate =emacs-setup.el=, and it can also generate
  complete documentation in various formats: HTML or LaTeX/PDF.

  Emacs has built in support for extracting and loading elisp within
  .org files via =org-babel-load-file=. Why not just use this on each
  .org file individually rather than orchestrating a process by which
  they are concatenated into a single, larger document? I want to
  focus on woven documentation. Why not just operate on just a larger
  .org file? I want to work towards modularity. Putting these two
  concepts together, I think of each .org file as a stand-alone entity
  that is both chapter in a larger story and section in a larger
  program.

  The remainder of this appendix details how this orchestration
  works. All of the functions and variables in this section begin with
  =jedcn-es/= to indicate their logical association with my (=jedcn=)
  emacs setup (=es=).

** Composite File

   The name of the composite .org file is =emacs-setup.org=, and its
   location is stored for future reference in =composite-org=.

#+begin_src emacs-lisp
  (setq jedcn-es/composite-org (concat
                                jedcn-es/dir
                                "/emacs-setup.org"))
#+end_src

** Component Files

   The list of files that will be included in the is stored in
   =files=. Order is significant. These files are presumed to be
   within =files-dir=.

#+begin_src emacs-lisp
  (setq jedcn-es/files-dir (concat
                            jedcn-es/dir
                            "/org"))

  (setq jedcn-es/files '("introduction.org"
                         "general-setup.org"
                         "personal-information.org"
                         "key-bindings.org"
                         "behaviors.org"
                         "modes.org"
                         "various-and-sundry.org"
                         "appendix-a.org"
                         "appendix-b.org"))
#+end_src

** Concatenation

   The composite file is created with =create-composite-org=, which in
   turn relies on =concat-files=, =files-dir=, and =files=, and
   =composite-org=.

#+begin_src emacs-lisp
  (defun jedcn-es/concat-files (the-files target-file)
    "Concatenate a list of THE-FILES into a TARGET-FILE"
    (let* ((original-buffer (current-buffer))
           (result-file target-file)
           (files the-files)
           (file (car files)))
      ;; do..
      (find-file file)
      (write-region (point-min) (point-max) result-file)
      (setq files (cdr files))
      (setq file (car files))
      ;; while
      (while files
        (find-file file)
        (write-region (point-min) (point-max) result-file t)
        (setq files (cdr files))
        (setq file (car files)))
      (switch-to-buffer original-buffer)))

  (defun jedcn-es/create-composite-org ()
    "Create a composite org file based on my list of config files"
    (jedcn-es/concat-files
     (mapcar (lambda (file)
               (concat jedcn-es/files-dir "/" file))
             jedcn-es/files)
     jedcn-es/composite-org))
#+end_src

** Extracting elisp

   Literate programming uses the verb "tangling" to describe the
   extraction of pure source code from its annotated source. We'll aim
   to extract the elisp from =composite-org= and place it into
   =composite-el=.

#+begin_src emacs-lisp
  (setq jedcn-es/composite-el (concat jedcn-es/dir "/emacs-setup.el"))
#+end_src

   Babel supports code extraction with a function named
   =org-babel-tangle-file=, and we can hook into the process described
   above as follows:

#+begin_src emacs-lisp
  (defun jedcn-es/tangle-composite-org ()
    (org-babel-tangle-file jedcn-es/composite-org jedcn-es/composite-el))
#+end_src

   When this has completed, we will have the tangled result residing
   at =composite-el=. The next logical step is to load it up and try
   it out:

#+begin_src emacs-lisp
  (defun jedcn-es/load-composite-el ()
    (load-file jedcn-es/composite-el))
#+end_src

   Stepping back, we can bundle up the creation of the composite .org
   file from its component pieces, then tangle it, and then load the
   result with =jedcn-es/rebuild-and-reload=:

#+begin_src emacs-lisp
  (defun jedcn-es/rebuild-and-reload ()
    "Rebuild the composite .org file, extract the elisp, and reload"
    (interactive)
    (jedcn-es/create-composite-org)
    (jedcn-es/tangle-composite-org)
    (jedcn-es/load-composite-el))
#+end_src

   This is the only function I make interactive. In practice, this
   means that I can fool around with my .org files, and then =M-x
   jedcn-es/rebuild-and-reload= to try out the latest changes.
