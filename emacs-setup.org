#+TITLE: Emacs Configuration
#+OPTIONS: toc:2 h:4

* Overview

  I use a simple mechanism for breaking down a single emacs
  configuration across several component files. Any one of these
  component files is written in a format that enables that file to
  simultaneously be more than one thing. Each file surely contains
  elisp that is used to configure emacs, but that same file also
  contains a prose explanation behind the motivation and impact of the
  associated elisp. The same mechanism combines these component pieces
  to form an overall configuration, ultimately within a single file an
  in pure elisp, that emacs is capable of interpreting. In the end,
  the elisp from each file provides a discrete section of the total,
  generated configuration, just as the prose explanation from each
  file comes to represent a section within this document.

  The value of this mechanism draws from the belief that complexity is
  reduced when each file can bear a single responsibility for
  describing one smaller part of a large configuration. This follows
  from the similar expectation that any one chapter within a larger
  document can rightly be expected to describe a self-contained idea.

  The notion of first creating a prose explanation of how "code" works
  and then embedding that same code within that explanation is known
  as [[http://en.wikipedia.org/wiki/Literate_programming][Literate Programming]]. This document describes two such systems.
  The first, and larger of the two, is a literately programmed emacs
  configuration. The second is a description of how literate
  programming is achieved within emacs and then meaningfully used to
  configure emacs.

** Background: Literate Programming in Emacs

   Emacs provides support for literate programming most directly
   through [[http://orgmode.org/][org-mode]], and, within org-mode, [[http://orgmode.org/worg/org-contrib/babel/][babel]]. When practicing
   literate programming in this style, you author org-mode documents
   as normal and you additionally embed source code within these
   documents. Org-mode gives you strong support for authoring a
   document of any type: you can export to various formats, structure
   documents with semantic headings, generate a table of contents,
   enjoy hyperlink syntax, and more. In addition to basic org-mode
   functionality, babel then allows you to include source code within
   these documents. Source code in this context enjoys the same
   support that emacs provides for normal editing. You can choose any
   single language or a mix of languages and you work in the mode of
   the language.

   Embedded source code and its easy extraction is the foundation that
   enables literate programming. Briefly, as you consider programming
   "a thing," you are given all of the tools you need to write a
   stand-alone document about that "thing." You are free to layout and
   follow a narrative that you see fit. This document is my prose
   explanation of my emacs configuration.

** An Emacs Configuration

   [[http://www.gnu.org/software/emacs/manual/html_node/emacs/Init-File.html][When Emacs is started, it normally tries to load a Lisp program
   from an initialization file, or init file for short.]] The mechanism
   I use for managing my configuration is centered around two elisp
   files. A smaller initialization file, =init.el=, lives in
   =~/.emacs.d=, a location that is well known to emacs and this file
   is read on start-up. =init.el= presumes that it will be able to
   load a much larger elisp file located at
   =~/emacs.d/emacs-setup/emacs-setup.el=.

   These two files, =init.el= and =emacs-setup.el=, are extracted from
   source code blocks within .org files using babel. Appendix A
   contains =init.el= in its entirety. The contents of =emac-setup.el=
   are spread across the remainder of the .org files and can be
   constructed by concatenating the extract results of all files.

   In summary, I use Org-mode and .org files to serve two purposes:

    + .org files contain documentation of my configuration. This
      documentation can be viewed on Github or translated into another
      format such as LaTeX or HTML.

    + .org files contain embedded elisp behind the same configuration.
      Babel, a feature of Org-mode, can parse a .org file and extract
      the associated elisp.

   Appendix A details how I install and setup emacs. It also contains
   information about how =init.el= and the start up process works.
   Appendix B defines a process that is capable of creating
   =emacs-setup.el= from distinct .org files.

   When it comes to elisp, functions and variables associated with my
   emacs setup will begin with =jedcn-es=. The first variable we
   define sets the expecation that the directory =emacs-setup/= can be
   placed (or linked to) underneath =~/.emacs.d=:

#+begin_src emacs-lisp
  (setq jedcn-es/dir (concat
                      user-emacs-directory
                      "emacs-setup"))
#+end_src
* General

** Package Repository

   Extensions for emacs are known as "packages," and emacs has a built
   in package management system. Emacs lisp packages are stored in
   archives (elpas) and, initially, emacs knows about a single such
   archive: http://elpa.gnu.org. This archive has approximately 50
   packages.  However, there are additional elpas out there, and I
   have had good luck finding up-to-date packages in
   http://melpa.milkbox.net/.

   That said, before I open up emacs for the first time on a new
   machine, I ensure that there's a =~/.emacs.d/Cask= file present and
   I've run =cask install= from a termianl when I am in my
   =~/.emacs.d= directory.

   My Cask file determines where I get packages from, and it calls out
   which packages I want installed.

** PATH

   Emacs can run shell commands on your behalf. When it does this, it
   needs to know about the equivalent of your PATH so it can find
   commands.

   I am not sure how this works. There is something that is an
   environment variabled named =PATH= that is reachable via =(getenv
   "PATH")= and there is something else that is a elisp variable named
   =exec-path=.

   Rather than interact with my shell and have Emacs learn values from
   a =$PATH= proper, I am explicit about setting both:

#+begin_src emacs-lisp
  (setq jedcn-env-path "/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin:/usr/texbin:/usr/local/share/npm/bin")

  (defun jedcn-sync-env-path-and-exec-path (desired-path)
    "Sets exec-path and env 'PATH' based on DESIRED-PATH"
    (setenv "PATH" desired-path)
    (setq exec-path (split-string desired-path ":")))

  (jedcn-sync-env-path-and-exec-path jedcn-env-path)
#+end_src
** Shell

   The following gives us a "login" shell. Without being quite sure
   what that means, I know that when this is in place my shell init
   files are run, my prompt looks normal, etc.

#+BEGIN_SRC emacs-lisp
  (setq explicit-bash-args '("--noediting" "--login"))
#+END_SRC

** UTF-8

  I picked this up from Magnars in his [[https://github.com/magnars/.emacs.d/blob/master/sane-defaults.el][sane-defaults.el]].

#+begin_src emacs-lisp
    (setq locale-coding-system 'utf-8)
    (set-terminal-coding-system 'utf-8)
    (set-keyboard-coding-system 'utf-8)
    (set-selection-coding-system 'utf-8)
    (prefer-coding-system 'utf-8)
    (set-language-environment 'utf-8)
    (set-default-coding-systems 'utf-8)
#+end_src

** Start Server

   Emacs is often run for hours (or days, or weeks) at a time. One of
   the benefits of such a long-lived process is that you can build a
   small tool, like =emacsclient= that can connect to a running emacs
   and request that something be edited. For example, you can tell git
   that it should use =emacsclient= whenever it needs to edit
   something:

#+begin_src sh :tangle no
  git config --global core.editor /usr/local/bin/emacsclient
#+end_src

   That said, here's the elisp that starts up an emacs server if it
   is needed:

#+begin_src emacs-lisp
  (require 'server)
  (if (server-running-p)
      (message "Server is running")
    (progn
      (message "Starting server")
      (server-start)))
#+end_src

** Save Place

  I got this one from Magnars: [[http://whattheemacsd.com/init.el-03.html][init.el-03]].

#+begin_src emacs-lisp
  (require 'saveplace)
  (setq-default save-place t)
  (setq save-place-file (expand-file-name ".places" user-emacs-directory))
#+end_src
** Appearance

*** Color Theme

    I always switch around themes. In general, I like Zenburn and
    Base16. I like monokai. And I'm trying out Sanity Inc's tomorrow collection.

#+BEGIN_SRC emacs-lisp
  (require 'moe-theme)
  (moe-theme-random-color)
  (moe-light)
#+END_SRC

*** Font

    I like a bigger font (say, 18) and I vary between "Monaco-18" or
    "Menlo-18".

#+begin_src emacs-lisp
  (if window-system
      (set-face-attribute 'default nil :font "Menlo-18"))
#+end_src

*** Mode Line

#+BEGIN_SRC emacs-lisp
  (require 'powerline)
  (powerline-moe-theme)
#+END_SRC

** Memory

   I believe that Emacs will initiate Garbage Collection every time
   the =gc-cons-threshold= is allocated. That's less than 1MB. I've
   got 16GB, so I'm flush with memory if it speeds up my Emacs.

   This comes from Lewang's [[https://github.com/lewang/flx][documentation on flx]].

#+BEGIN_SRC emacs-lisp
  (setq gc-cons-threshold 20000000)
#+END_SRC
* Personal Information

#+begin_src emacs-lisp
  (setq user-full-name "Jed Northridge"
        user-mail-address "northridge@gmail.com")
#+end_src
* Key Bindings

  My main inspiration for keybindings have come from [[https://github.com/technomancy/emacs-starter-kit/blob/v2/modules/starter-kit-bindings.el][ESK]] and from
  [[https://github.com/magnars/.emacs.d/blob/master/key-bindings.el][Magnars]].

  If a particular mode has a global keybinding, then they keybinding
  will be with the mode in modes.org.

** See Occurrences while Searching

   If you are searching for something, and you press =C-o=, you can
   see all of the occurrences of that something within the file. Once
   that *Occur* window comes up, you can press =e= to start
   editing. You can press =C-c C-c= to get out of it.

#+BEGIN_SRC emacs-lisp
  (define-key isearch-mode-map (kbd "C-o")
    (lambda () (interactive)
      (let ((case-fold-search isearch-case-fold-search))
        (occur (if isearch-regexp isearch-string (regexp-quote isearch-string))))))
#+END_SRC

** Running Methods

   When it comes to running methods explicitly, I always use C-x C-m.
   I picked this up from Steve Yegge's [[https://sites.google.com/site/steveyegge2/effective-emacs][Effective Emacs]]. He says use
   =execute-extended-command=, but I always use smex.

#+BEGIN_SRC emacs-lisp
  (global-set-key "\C-x\C-m" 'smex)
#+END_SRC

** Text Size

   Making text larger or smaller with ease is something I use every
   day, several times a day. This happens most commonly when I am
   showing someone something in emacs (say, pairing or running a
   meeting), but also when I am at home and do not have my glasses.
   These particular keybindings are all about the =+= and the =-=.

#+BEGIN_SRC emacs-lisp
  (define-key global-map (kbd "C-+") 'text-scale-increase)
  (define-key global-map (kbd "C--") 'text-scale-decrease)
#+END_SRC

** Goto Line

  The following makes it so that when I press =C-x g= I can expect to
  be prompted to enter a line number to jump to it.

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-x g") 'goto-line)
#+END_SRC

  And the elisp below makes it so that whatever goto-line was bound to
  is now bound to a new function: goto-line-with-feedback.

  In turn, goto-line-with-feedback modifies the buffer you are working
  in to show line numbers but only when you are actively looking to
  pick a number.

  The point of showing line numbers is to give you an idea of where
  you will end up.

  The point of *only* showing them while going to a line is to keep
  the screen free of distractions (line numbers) unless it is helpful.

  This comes from [[http://whattheemacsd.com/key-bindings.el-01.html][this post]] within "what the emacs.d."

#+BEGIN_SRC emacs-lisp
  (global-set-key [remap goto-line] 'goto-line-with-feedback)

  (defun goto-line-with-feedback ()
    "Show line numbers temporarily, while prompting for the line number input"
    (interactive)
    (unwind-protect
        (progn
          (linum-mode 1)
          (goto-line (read-number "Goto line: ")))
      (linum-mode -1)))
#+END_SRC

  Finally, from rdallasgray's [[https://github.com/rdallasgray/graphene][Graphene]], sometimes the line numbers
  look weird, so we give them some extra space.

#+BEGIN_SRC emacs-lisp
  (setq linum-format " %4d ")
#+END_SRC

** MacOS's "Command"

   I think keys called 'super' and 'hyper' used to appear on the
   keyboards of fabled 'Lisp Machines,' as described in this ErgoEmacs
   post about [[http://ergoemacs.org/emacs/emacs_hyper_super_keys.html][Super and Hyper Keys]]. I may take advantage of these some
   day, but for now I am happy to have both the 'alt/option' key and
   the 'command' key on my Mac do the same thing: meta.

   Given the default setup of my brew installed emacs, the following
   change makes it so that "command does meta"

   If I am back this way in the future again, I'd like to remind
   myself to consider the following variables: mac-option-modifier,
   mac-command-modifier, and ns-function-modifer.

#+BEGIN_SRC emacs-lisp
  (setq mac-command-modifier 'meta)
#+END_SRC

** Movement

   I rely on standard emacs commands to move around, with the
   following enhancements:

*** Using shift makes standard movement 5x faster

    This comes from Magnars in this [[http://whattheemacsd.com/key-bindings.el-02.html][post of whattheemacsd.com]].

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-S-n")
                  (lambda ()
                    (interactive)
                    (ignore-errors (next-line 5))))

  (global-set-key (kbd "C-S-p")
                  (lambda ()
                    (interactive)
                    (ignore-errors (previous-line 5))))

  (global-set-key (kbd "C-S-f")
                  (lambda ()
                    (interactive)
                    (ignore-errors (forward-char 5))))

  (global-set-key (kbd "C-S-b")
                  (lambda ()
                    (interactive)
                    (ignore-errors (backward-char 5))))
#+END_SRC

*** Move current line up or down

    This matches what Magnars says in [[http://whattheemacsd.com/editing-defuns.el-02.html][this post]], except I also use
    META.

#+BEGIN_SRC emacs-lisp
  (defun move-line-down ()
    (interactive)
    (let ((col (current-column)))
      (save-excursion
        (forward-line)
        (transpose-lines 1))
      (forward-line)
      (move-to-column col)))

  (defun move-line-up ()
    (interactive)
    (let ((col (current-column)))
      (save-excursion
        (forward-line)
        (transpose-lines -1))
      (move-to-column col)))
  (global-set-key (kbd "<C-M-S-down>") 'move-line-down)
  (global-set-key (kbd "<C-M-S-up>") 'move-line-up)
#+END_SRC

** Window Management

   I usually focus on a single buffer at a time, but sometimes I
   split vertically or horizontally (and possibly split again..) and
   when I do I like to control the size of the buffer I am presently
   typing in with the following key bindings:

   |-------------------+--------|
   | Vertical Expand   | CTRL-> |
   | Vertical Shrink   | CTRL-< |
   |-------------------+--------|
   | Horizontal Expand | CTRL-. |
   | Horizontal Shrink | CTRL-, |
   |-------------------+--------|

   These keybindings (and the elisp that makes them possible) come
   from rdallasgray's graphene package.

   See [[https://github.com/rdallasgray/graphene/blob/master/graphene-helper-functions.el#L89][graphene-helper-functions.el]].

   Graphene is awesome. On my (North American) keyboard these keys are
   right next to each other in a similar fashion as are the + and -
   which are used above in conjunction with CTRL to increase and
   decrease text scale.

   CTRL- collides with =org-cycle-agenda-files= when in org-mode, and
   I'd like decrease-window-width to take precedence.

#+BEGIN_SRC emacs-lisp
  (defun increase-window-height (&optional arg)
    "Make the window taller by one line. Useful when bound to a repeatable key combination."
    (interactive "p")
    (enlarge-window arg))

  (defun decrease-window-height (&optional arg)
    "Make the window shorter by one line. Useful when bound to a repeatable key combination."
    (interactive "p")
    (enlarge-window (- 0 arg)))

  (defun decrease-window-width (&optional arg)
    "Make the window narrower by one line. Useful when bound to a repeatable key combination."
    (interactive "p")
    (enlarge-window (- 0 arg) t))

  (defun increase-window-width (&optional arg)
    "Make the window shorter by one line. Useful when bound to a repeatable key combination."
    (interactive "p")
    (enlarge-window arg t))

  (global-set-key (kbd "C->")
                  'increase-window-height)

  (global-set-key (kbd "C-<")
                  'decrease-window-height)

  (global-set-key (kbd "C-,")
                  'decrease-window-width)

  (global-set-key (kbd "C-.")
                  'increase-window-width)

  (add-hook 'org-mode-hook
            (lambda ()
              (define-key org-mode-map [(ctrl \,)]
                'decrease-window-width)))
#+END_SRC

** New Buffers

   Create a new buffer.

   This comes from Graphene.

#+BEGIN_SRC emacs-lisp
  (defun create-new-buffer ()
    "Create a new buffer named *new*[num]."
    (interactive)
    (switch-to-buffer (generate-new-buffer-name "*new*")))

  (global-set-key (kbd "C-c n")
                  'create-new-buffer)
#+END_SRC

** New Instances of Emacs

   It is usually the case that a single instance of emacs is dedicated
   to a single project. Before I did project management this way, I
   only had a single instance of emacs, ever.

   This comes from Graphene.

#+BEGIN_SRC emacs-lisp
  (when window-system
    (defun new-emacs-instance ()
      (interactive)
      (let ((path-to-emacs
             (locate-file invocation-name
                          (list invocation-directory) exec-suffixes)))
        (call-process path-to-emacs nil 0 nil)))

    (global-set-key (kbd "C-c N")
                    'new-emacs-instance))
#+END_SRC
** Newline Anywhere

   Press "M-RET" and get a new line that's indented. The intent is
   that can press it when you are at the beginning of a line, in the
   middle of a line, or at the end of a line.

   This is from Graphene.

#+BEGIN_SRC emacs-lisp
  (defun newline-anywhere ()
    "Add a newline from anywhere in the line."
    (interactive)
    (end-of-line)
    (newline-and-indent))

  (global-set-key (kbd "M-RET")
                  'newline-anywhere)
#+END_SRC
* Behaviors

  ...

  be·hav·ior
  /biˈhāvyər/
  Noun

  + The way in which one acts or conducts oneself, esp. toward others:
    "his insulting behavior towards me".

  + The way in which an animal or person acts in response to a
    particular situation or stimulus: "the feeding behavior of
    predators".

  ...

** Miscellaneous

   Do not "ding" all of the time, and instead flash the screen. Do not
   show the Emacs "splash" screen.

#+begin_src emacs-lisp
  (setq visible-bell t
        inhibit-startup-message t)
#+end_src

   Whenever a new buffer is created, look at the name of the buffer
   and activate the major-mode that corresponds to it. I learned this
   from a [[http://www.reddit.com/r/emacs/comments/2188jl/my_lovehate_relationship_with_emacs/cgawngs][comment on Reddit]].

#+BEGIN_SRC emacs-lisp
  (defun major-mode-from-name ()
    "Choose proper mode for buffers created by switch-to-buffer."
    (let ((buffer-file-name (or buffer-file-name (buffer-name))))
      (set-auto-mode)))
  (setq-default major-mode 'major-mode-from-name)
#+END_SRC

** Whitespace Cleanup

   The following creates a function that cleans up whitespace, and
   then adds a hook that makes this happen each time you save. It
   comes from a post within "what the emacs.d," specifically titled
   [[http://whattheemacsd.com/buffer-defuns.el-01.html][buffer defuns]].

#+begin_src emacs-lisp
  (defun cleanup-buffer-safe ()
    "Perform a bunch of safe operations on the whitespace content of a buffer."
    (interactive)
    (untabify (point-min) (point-max))
    (delete-trailing-whitespace)
    (set-buffer-file-coding-system 'utf-8))

  (add-hook 'before-save-hook 'cleanup-buffer-safe)
#+end_src

** Yes or No?

   Emacs often asks you to type "yes or no" to proceed. As an example,
   consider when you are in magit, and you press "k" to kill off a
   hunk. I am happy to have a confirmation before something is
   deleted, but I prefer to just press "y" instead of "y-e-s-<RETURN>"

#+begin_src emacs-lisp
  (defalias 'yes-or-no-p 'y-or-n-p)
#+end_src

** Autofill

   By observation alone, =auto-fill-mode= makes it so that words wrap
   around the screen by inserting a new line once you go past a
   certain spot. I want to auto-fill if I am working on text. When I
   am programming, I only want to auto-fill if I am writing a comment.

   Both of these come from technomancy in v2 of the [[https://github.com/technomancy/emacs-starter-kit][emacs-starter-kit]].

#+begin_src emacs-lisp
  (defun esk-local-comment-auto-fill ()
    (set (make-local-variable 'comment-auto-fill-only-comments) t)
    (auto-fill-mode t))
  (add-hook 'prog-mode-hook 'esk-local-comment-auto-fill)

  (add-hook 'text-mode-hook 'turn-on-auto-fill)
#+end_src

** Display Line + Column Numbers

   Show line and column numbers all the time.

#+begin_src emacs-lisp
  (setq line-number-mode t)
  (setq column-number-mode t)
#+end_src

** Highlight Current Line when Programming

   Highlight the current line. This comes from technomancy in v2 of
   the [[https://github.com/technomancy/emacs-starter-kit][emacs-starter-kit]].

#+begin_src emacs-lisp
  (defun esk-turn-on-hl-line-mode ()
    (when (> (display-color-cells) 8)
      (hl-line-mode t)))

  (add-hook 'prog-mode-hook 'esk-turn-on-hl-line-mode)
#+end_src

** Use λ instead of lambda

   If you see "lambda" replace it with a λ. This comes from
   technomancy in v2 of the [[https://github.com/technomancy/emacs-starter-kit][emacs-starter-kit]].

#+begin_src emacs-lisp
  (defun esk-pretty-lambdas ()
    (font-lock-add-keywords
     nil `(("(?\\(lambda\\>\\)"
            (0 (progn (compose-region (match-beginning 1) (match-end 1)
                                      ,(make-char 'greek-iso8859-7 107))
                      nil))))))

  (add-hook 'prog-mode-hook 'esk-pretty-lambdas)
#+end_src
* Major Modes, Minor Modes, and Packages

  Major and Minor Modes are one avenue that bring significant
  functionality into Emacs.

  The difference between Major and Minor Mode is that only a single
  Major mode may be in use at a time. A Major Mode typically defines
  the type of document that you are creating, while a Minor Mode
  provides conveniences that may be helpful with many types of files.

  =org-mode=, =text-mode=, and =ruby-mode= are all major modes. They
  are used to create files of a certain type (org, text, and
  ruby). They define keybindings. They define how documents should be
  displayed and interacted with.

  =auto-fill= is a minor mode. It helps you "toggle automatic line
  breaking," which is helpful in =org-mode=, but also in =text-mode=
  and =ruby-mode=.

  Finally, functionality can be delivered independently from a
  mode. For example, a library like =better-defaults= can provide
  elisp code that configures emacs regardless of whether or not you
  ever make use of =org-mode= (a major mode) or =auto-fill-mode= (a
  minor mode).

  This section describes the core modes that I use, and how they are
  configured. It breaks down into Major Modes, Minor Modes, and
  Packages.

  Another way to organize this section is by functional topic. So, for
  example, put everything I do associated with setting up a Ruby
  environment into a general section regardless of whether it's
  achieved through using a major mode, minor mode, or package.

  The only topic organized in this manner is Project Management, which
  is in its own section.

** Getting Code

   My main method for retrieving and installing source code is via the
   bare package management system. When I'd like to try something out,
   I type =M-x package-list-packages= and look around. As you move
   throughout the resulting buffer, if you see something you like you
   can press =i= and the package on the same line as your cursor will
   be marked for an upcoming installation. When you are ready, press
   'x' to install each package that has been marked in this way.

   I'm using =pallet= and this means that changes made through this
   system will be written to my =~/.emacs.d/Cask= file. If I have
   additional configuration changes I'd like to make, I add a section
   in this file with those changes.

   Because of the way I'm using =emacs-setup=, I'll copy the
   ~/.emacs.d/Cask into wherever I've checked out =emacs-setup= as I
   make changes.

** Major Modes
*** Magit

    Everyone *loves* magit.

    I like to think "C-x m"agit.

#+begin_src emacs-lisp
  (global-set-key (kbd "C-x m") 'magit-status)
#+end_src

    Here are two great blog posts about magit: [[http://whattheemacsd.com/setup-magit.el-01.html][Setup Magit #1]] and
    [[http://whattheemacsd.com/setup-magit.el-02.html][Setup Magit #2]].  The main points are:

    + Give Magit full screen when you start it.

    + Setup Magit so that pressing "q" gets rid of full screen.

    + Setup Magit so that pressing "W" toggles paying attention to
      whitespace.

    I happen to have =emacsclient= installed in two places, one at
    =/usr/bin= and another at =/usr/local/bin=. The one at =/usr/bin=
    cannot find my emacs server and this causes Magit to freeze
    whenever I try to commit. This is why I explicitly set
    =magit-emacsclient-executable=.

#+begin_src emacs-lisp
  (require 'magit)

  (defadvice magit-status (around magit-fullscreen activate)
    (window-configuration-to-register :magit-fullscreen)
    ad-do-it
    (delete-other-windows))

  (defun magit-quit-session ()
    "Restores the previous window configuration and kills the magit buffer"
    (interactive)
    (kill-buffer)
    (jump-to-register :magit-fullscreen))

  (define-key magit-status-mode-map (kbd "q") 'magit-quit-session)

  (defun magit-toggle-whitespace ()
    (interactive)
    (if (member "-w" magit-diff-options)
        (magit-dont-ignore-whitespace)
      (magit-ignore-whitespace)))

  (defun magit-ignore-whitespace ()
    (interactive)
    (add-to-list 'magit-diff-options "-w")
    (magit-refresh))

  (defun magit-dont-ignore-whitespace ()
    (interactive)
    (setq magit-diff-options (remove "-w" magit-diff-options))
    (magit-refresh))

  (define-key magit-status-mode-map (kbd "W") 'magit-toggle-whitespace)

  (setq magit-emacsclient-executable "/usr/local/bin/emacsclient")
#+end_src

    In Magit, the variable =magit-diff-refine-hunk= controls the
    granularity that is displayed when it comes to diff-hunks. If you
    set it to "all" you get better insight into what's changed within
    a line.

#+BEGIN_SRC emacs-lisp
  (setq magit-diff-refine-hunk 'all)
#+END_SRC

*** org-mode

    OrgMode is a wonderful thing.

    I used to use it to track all of my time. That's stopped
    recently.

**** Key Bindings

     [[http://orgmode.org/manual/Activation.html#Activation][Org-mode documentation]] suggests that some functions be globally
     bound, and I follow their defaults:

#+begin_src emacs-lisp
  (global-set-key "\C-ca" 'org-agenda)
  (global-set-key "\C-cl" 'org-store-link)
  (global-set-key "\C-cc" 'org-capture)
  (global-set-key "\C-cb" 'org-iswitchb)
#+end_src

**** Defaults

     When I open a .org file, I like to see all of the headlines but
     none of the text:

#+begin_src emacs-lisp
  (setq org-startup-folded 'content)
#+end_src

     Hiding the stars looks cleaner to me:

#+begin_src emacs-lisp
  (setq org-hide-leading-stars 'hidestars)
#+end_src

**** Recording Timestamps

     This setting makes it so that a timestamp is recorded whenever
     you mark a task as done. [[http://orgmode.org/manual/Closing-items.html#Closing-items][Manual entry]].

#+begin_src emacs-lisp
  (setq org-log-done 'time)
#+end_src

**** Clock

     These settings are necessary to clock history across emacs
     sessions according to [[http://orgmode.org/manual/Clocking-work-time.html][this documentation]].

#+begin_src emacs-lisp
  (setq org-clock-persist 'history)
  (org-clock-persistence-insinuate)
#+end_src

**** Diary

     Including the "diary" makes it so that your agenda has official
     holidays in it.

#+begin_src emacs-lisp
  (setq org-agenda-include-diary t)
#+end_src

**** Code Blocks

     These emacs configuration files (.org, .el) use org's "code
     blocks" extensively, and the following has Emacs pay attention to
     the type of code within the blocks.

#+begin_src emacs-lisp
  (setq org-src-fontify-natively t)
#+end_src

***** Editing Code Blocks

      With your cursor over one of these code blocks you can type C-c '
      and a new buffer will open for editing just that content.

***** Executing Code Blocks

      With your cursor over one of these code blocks you can type C-c
      C-c and, if the code block is one of the languages that has been
      configured to be run, the block will be executed and the results
      printed nearby.

      By default, only emacs-lisp is configured to be executed.  The
      following block makes it so that ruby and shell scripts are too.

      Here's the documentation for this: [[http://orgmode.org/worg/org-contrib/babel/languages.html][babel/languages]].

      I've stopped doing this as much as I did in the past.

#+begin_src emacs-lisp
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((emacs-lisp . t)
     (ruby . t)
     (sh . t)))
#+end_src

**** Agenda, Tasks

     I will plan on keeping .org files underneath =~/notes/org=.

#+begin_src emacs-lisp
  (setq org-agenda-files '("~/notes/org"))
#+end_src

*** markdown-mode

    I write in Markdown all the time. I used to have emacs compile
    markdown in HTML, but I stopped. I prefer to use other tools to do
    this for me.

#+begin_src emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.md$" . markdown-mode))
#+end_src

*** coffee-mode

    CoffeeScript. It's a thing.

    I can initiate a translation of coffee into js with
    =coffee-compile-file=, and this is possible because I've done an
    =npm install -g coffee=. This means the =coffee= executable is
    installed at =/usr/share/local/npm/bin=. This directory is in the
    PATH of emacs via =jedcn-env-path=.

#+begin_src emacs-lisp
  (setq coffee-tab-width 2)
#+end_src

*** haml-mode

    I use this often, but I don't tweak it. It's in the Cask file as
    "haml-mode".

*** puppet-mode

#+begin_src emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.pp$" . puppet-mode))
#+end_src

*** slim-mode

    I use this rarely, but I don't tweak it. It's in the Cask file as
    "slim-mode".

*** yaml-mode

#+begin_src emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.yml$" . yaml-mode))
#+end_src

*** js-mode

    I love JavaScript.

#+BEGIN_SRC emacs-lisp
  (setq js-indent-level 2)
#+END_SRC

*** feature-mode

  I don't often write Gherkin at work, but I do try to use Cucumber
  whenever I get the chance on side projects. So far I've been using
  this mode mainly for syntax highlighting.

*** ruby-mode

    I really enjoy writing ruby.

    At a high level, my MacOS has RVM installed from http://rvm.io.

    Then, my emacs uses a package named rvm that understands how
    http://rvm.io works, and can direct emacs to use any of the
    various rubies that rvm provides.

    I explicitly use the default ruby from RVM, but Emacs also updates
    the ruby I'm using each time I start editing a file in
    ruby-mode. I think this works by looking at the location of the
    file I'm editing, looking "up" to find the associated .rvmrc or
    .ruby-version, and then activating it.

    With all of that said, my main flow is to run rspec and cucumber
    from within emacs. This capability is provided by feature-mode and
    rspec-mode.

    The main key bindings I use are:

    + =C-c , v=

      Run rspec or cucumber against the file I'm editing

    + =C-c , s=

      Run rspec or cucumber against the single line of the spec or
      feature I'm editing.

    For now, the main thing I do is turn on ruby-mode when I'm
    editing well known file types:

#+begin_src emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.rake$" . ruby-mode))
  (add-to-list 'auto-mode-alist '("\\.gemspec$" . ruby-mode))
  (add-to-list 'auto-mode-alist '("\\.ru$" . ruby-mode))
  (add-to-list 'auto-mode-alist '("Rakefile$" . ruby-mode))
  (add-to-list 'auto-mode-alist '("Gemfile$" . ruby-mode))
  (add-to-list 'auto-mode-alist '("Capfile$" . ruby-mode))
  (add-to-list 'auto-mode-alist '("Vagrantfile$" . ruby-mode))
  (add-to-list 'auto-mode-alist '("\\.thor$" . ruby-mode))
  (add-to-list 'auto-mode-alist '("Thorfile$" . ruby-mode))
  (add-to-list 'auto-mode-alist '("Guardfile" . ruby-mode))
#+end_src

    Also, when you press return in ruby, go to a new line and indent
    rather than just going to a new line.

#+BEGIN_SRC emacs-lisp
  (add-hook 'ruby-mode-hook
            (lambda ()
              (define-key (current-local-map) [remap newline] 'reindent-then-newline-and-indent)))
#+END_SRC

** Minor Modes
*** yasnippet

    My favorite snippet to use is =dbg=, which I found in Jim Weirich's
    emacs setup [[https://github.com/jimweirich/emacs-setup/blob/master/snippets/text-mode/ruby-mode/dbg][here]].

#+begin_src emacs-lisp
  (require 'yasnippet)
  (setq yas-snippet-dirs (concat jedcn-es/dir "/snippets"))
#+end_src

    When I was setting up yasnippet, I saw the following in the official
    documentation:

#+begin_src emacs-lisp
  (yas-global-mode 1)
#+end_src

*** smartparens

#+BEGIN_SRC emacs-lisp
  (require 'smartparens-config)
  (smartparens-global-mode)
  (show-smartparens-global-mode +1)
#+END_SRC

*** ace-jump-mode

    I'm giving ace-jump-mode a try. I often search forward and
    backward to jump around, but maybe there's room for improvement.

    =C-c SPC= is recommended with the basic setup, and I hook into the
    org-mode-map so I can have a consistent binding there.

#+begin_src emacs-lisp
  (require 'ace-jump-mode)
  (define-key global-map
    (kbd "C-c SPC") 'ace-jump-mode)
  (add-hook 'org-mode-hook
            (lambda ()
              (define-key org-mode-map
                (kbd "C-c SPC") 'ace-jump-mode)))
#+end_src

*** flycheck

    This is pretty cool. I never got flymake working right, and this
    seems to "just do the right thing." Plus-- the documentation is
    quite good: http://flycheck.readthedocs.org/en/latest/

    The tools that I am powering flycheck with are:

    - jshint :: via =npm install -g jshint=
    - jsonlint :: via =npm install -g jsonlint=
    - coffeelint :: via =npm install -g coffeelint=

    I make sure these are available to emacs by making sure that the
    location that npm puts stuff (=/usr/local/share/npm/bin=) is in my
    =jedcn-env-path=.

    Sometimes "checkers" will fail, and I've found reading through the
    source the best way to troubleshoot. For example-- at one point I
    had a coffeelint that was old (say, 0.6.0) and the source of the
    checker indicated that you needed 1.0.0+, and so re-install was in
    order.

    Further-- sometimes the wrong checkers get loaded. For example--
    before I had json-mode, I'd use js-mode when dealing with a .json
    file, and this would load jshint, and jshint would puke on JSON.

    This directive causes it to be used everywhere:

#+BEGIN_SRC emacs-lisp
  (add-hook 'after-init-hook #'global-flycheck-mode)
#+END_SRC

    If things don't work, I'll see an error message briefly
    flash. This is annoying enough that I track down the problem even
    if I don't really care to have flycheck.

*** rspec-mode

    I *love* rspec.

    I also have been using ZSH, and when I was getting rspec-mode up
    and running a few months ago, I ran into trouble. Thankfully, the
    author of rspec mode had [[https://github.com/pezra/rspec-mode][a solution for using rspec mode with ZSH]].

#+begin_src emacs-lisp
  (defadvice rspec-compile (around rspec-compile-around)
    "Use BASH shell for running the specs because of ZSH issues."
    (let ((shell-file-name "/bin/bash"))
      ad-do-it))
  (ad-activate 'rspec-compile)
#+end_src

** Packages
*** better-defaults

    I started with Emacs Starter Kit, and am following its progression
    from v1 to v2 and, now, v3. In v3 the esk becomes prose only, and
    identifies =better-defaults= as a single package with "universal
    appeal."

*** diminish

    In Emacs, the "mode line" shows you information about the active
    major and any active minor modes. In some cases this is helpful
    and in other cases this is just "noise." The diminish library
    allows you to eliminate (or change) contributions that packages
    make to the mode line.

    I found out about it through this [[http://whattheemacsd.com/init.el-04.html][post]]. It lives [[http://www.eskimo.com/~seldon/diminish.el][here]].

    You can see which modes have been diminished with
    =diminished-modes=.

#+BEGIN_SRC emacs-lisp
  (eval-after-load "yasnippet" '(diminish 'yas-minor-mode))
  (eval-after-load "project-persist" '(diminish 'project-persist-mode))
  (diminish 'auto-fill-function)
  (diminish 'smartparens-mode)
#+END_SRC

*** rvm

    For emacs, on a MacOS, I believe the following configures my setup
    so that I'll use the default ruby provided by RVM when I need
    ruby.

#+begin_src emacs-lisp
  (rvm-use-default)
#+end_src

    I was reading a [[http://devblog.avdi.org/2011/10/11/rvm-el-and-inf-ruby-emacs-reboot-14/][blog post by Avdi Grimm about how he was using RVM]]
    the other day, and that's where I picked up the following helpful
    snippet that works with the emacs rvm subsystem to activate the
    correct version of ruby each time you open a ruby-based file:

#+begin_src emacs-lisp
  (add-hook 'ruby-mode-hook
            (lambda () (rvm-activate-corresponding-ruby)))
#+end_src

*** expand-region

    The functionality from =expand-region= is most easily described by
    watching the excellent emacsrocks.com [[http://emacsrocks.com/e09.html][Introductory Video]]. The
    project is hosted on [[https://github.com/magnars/expand-region.el][github]], and I use a standard setup for it,
    which means that you get things started by pressing =C-==.

#+begin_src emacs-lisp
  (require 'expand-region)
  (global-set-key (kbd "C-=") 'er/expand-region)
#+end_src

*** multiple-cursors

    This video, http://emacsrocks.com/e13.html, blew my
    mind. Especially the writeable dired. Hah!

    I'm not sure how to use this mode yet, or what the right bindings
    are, but I think the main functions are:

    + mc/mark-next-like-this
    + mc/mark-all-like-this
    + mc/edit-lines

*** helm

    I've recently switched from a combination of smex and ido to
    [[https://github.com/emacs-helm/helm][helm]]. My central motivation was to get toward "a single vertical
    line" per choice, and to gain access to the number of plugins.

    Here's my basic helm setup. We begin with initialization:

#+BEGIN_SRC emacs-lisp
  (require 'helm)
  (require 'helm-config)
#+END_SRC

    Use helm for command completion:

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "M-x") 'helm-M-x)
#+END_SRC

    Use helm for buffer selection:

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-x b") 'helm-mini)
#+END_SRC

    Use helm for viewing and selecting the contents in the kill ring:

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "M-y") 'helm-show-kill-ring)
#+END_SRC

    I'm not sure about these- they come from [[https://tuhdo.github.io/helm-intro.html][this introduction]].

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-x C-f") 'helm-find-files)
  (global-set-key (kbd "C-c h s") 'helm-semantic-or-imenu)

  ;; Don't use marks or mark-ring. Start?
  (global-set-key (kbd "C-c m") 'helm-all-mark-rings)
  (global-set-key (kbd "C-c h o") 'helm-occur)

  ;; Don't use eshell. Start?
  (add-hook 'eshell-mode-hook
            #'(lambda ()
                (define-key eshell-mode-map (kbd "M-l")  'helm-eshell-history)))
#+END_SRC

    Make it so that pressing TAB while using helm will visit the
    buffer / file / whatever. The default key binding for this is
    C-z, and so we swap that out with what TAB used to do.

#+BEGIN_SRC emacs-lisp
  (define-key helm-map (kbd "<tab>") 'helm-execute-persistent-action)
  (define-key helm-map (kbd "C-z")  'helm-select-action)
#+END_SRC

    Activate helm everywhere.

#+BEGIN_SRC emacs-lisp
  (helm-mode 1)
#+END_SRC

*** company-mode

    When it comes to completion, I was considering [[http://cx4a.org/software/auto-complete/][auto-complete]] and
    [[https://company-mode.github.io/][company-mode]]. I'm trying company-mode for now.

#+BEGIN_SRC emacs-lisp
  (add-hook 'after-init-hook 'global-company-mode)
#+END_SRC

    And this is my main keybinding for starting things up. It used to
    be "hippie-expand:"

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "M-/") 'company-complete)
#+END_SRC

** Functional Areas
*** Project Management

    My typical setup has dozens of projects all underneath two or
    three common directories. The setup I am using here gives me fuzzy
    search across all projects, and once I pick a project, I can get
    fuzzy search across all files within.

    This is achieved, primarily, by software written by [[https://github.com/rdallasgray][rdallasgray]]
    and [[https://github.com/bbatsov][bbatsov]].

    I can switch between projects with [[https://github.com/rdallasgray/project-persist][project-persist]]. Once I'm in a
    project, [[https://github.com/bbatsov/projectile][projectile]] helps me find files.

**** projectile

#+BEGIN_SRC emacs-lisp
  (require 'projectile)
#+END_SRC

**** project-persist

     [[https://github.com/rdallasgray/project-persist][project-persist]] is a lightweight means for keeping track of
     projects. Projects have names and a location on your file
     system. Optionally, they can have settings associated with them.

     That said, you can use project-persist to find a project and
     close a project, and project-persist provides hooks into these
     events.

***** Basic Installation

#+BEGIN_SRC emacs-lisp
  (project-persist-mode t)
#+END_SRC

***** File System Integration

      I layout code on my computer in the following manner:

       + ~/c/misc :: Miscellaneous projects live here.
       + ~/c/personal :: Personal projects live here.
       + ~/d :: Code that I don't author, but that I look at
                semi-regularly lives here.

      For example, if I checkout the source for rake on my computer
      and I just scan through it, it lives at =~/d/rake/=. If I am
      actively working on a project named reveal-ck, it lives at
      =~/c/personal/reveal-ck/=.

      I capture these locations in =jedcn/pp-project-roots=.

      The following code scans through these directories and builds
      project-persist entries for each directory that is found. The
      main interactive entry point is =jedcn-pp/rebuild-projects=.

#+BEGIN_SRC emacs-lisp
  (require 'project-persist)

  (setq jedcn/pp-project-roots
        (list (concat (getenv "HOME") "/c/galileo")
              (concat (getenv "HOME") "/c/misc")
              (concat (getenv "HOME") "/c/personal")
              (concat (getenv "HOME") "/d")))

  (defun jedcn/pp-create-projects-under-root (root)
    "Create project-persist projects for directories under root"
    (let* ((dirs (directory-files root))
           (dir (car dirs))
           (ignore-dirs '("." ".." ".DS_Store")))
      (while dirs
        (unless (member dir ignore-dirs)
          (unless (pp/project-exists dir)
            (let ((dir-path (concat root "/" dir "/")))
              (if (file-directory-p dir-path)
                  (pp/project-setup dir-path dir)))))
        (setq dirs (cdr dirs))
        (setq dir (car dirs)))))

  (defun jedcn/pp-create-all-projects (project-roots)
    "Create all project-persist projects based on PROJECT-ROOTS"
    (let* ((project-root (car project-roots)))
      (while project-roots
        (when (file-exists-p project-root)
          (jedcn/pp-create-projects-under-root project-root))
        (setq project-roots (cdr project-roots))
        (setq project-root (car project-roots)))))

  (defun jedcn/pp-destroy-all-projects ()
    "Remove all previously created project-persist projects"
    (let ((projects (pp/project-list)))
      (while projects
        (pp/project-destroy (car projects))
        (setq projects (cdr projects)))))

  (defun jedcn-pp/rebuild-projects ()
    (interactive)
    (if (jedcn-pp/project-persist-initialized-p)
      (jedcn/pp-destroy-all-projects))
    (jedcn/pp-create-all-projects jedcn/pp-project-roots))

  (defun jedcn-pp/project-persist-initialized-p ()
    "Has project-persist been initialized?"
    (file-directory-p project-persist-settings-dir))

  (unless (jedcn-pp/project-persist-initialized-p)
    (message "Initializing Project Persist.")
    (jedcn-pp/rebuild-projects))
#+END_SRC

***** Hooks

      project-persist is intentionally minimal, so, to get something
      out of it you need to register hooks into its main events. These
      revolve around project management.

      The hooks are:

      + project-persist-before-load-hook
      + project-persist-after-close-hook
      + project-persist-after-load-hook
      + project-persist-after-save-hook

      The hook my setup uses is defined below.

#+BEGIN_SRC emacs-lisp
  (defun jedcn-after-open-project (dir)
    "Open up a dired for that project."
    (dired dir))

  (add-hook 'project-persist-after-load-hook
            (lambda ()
              (jedcn-after-open-project project-persist-current-project-root-dir)))
#+END_SRC

***** Key Bindings

      The goal is to have a single binding to open a project, and a
      another binding to find a file within a project.

      Right now they are:

      1. =C-c p=: Mnemonic: Choose Project
      2. =C-c f=: Mnemonic: Choose File

#+BEGIN_SRC emacs-lisp
  (global-set-key "\C-cp"
                  'helm-project-persist)

  (global-set-key "\C-cf"
                  'helm-projectile)
#+END_SRC
* Various and Sundry

** Jim Weirich's eval-buffer

   I saw Jim Weirich give a great talk at one of the keynotes of Ruby
   Conf 2012. The way he used buffer evaluation was just awesome!

   His setup (which I think is described below) allows him to
   consistently show you one piece of code and then pair that code up
   with the output that comes from executing it.

   Unlike using an inferior-ruby process, the resulting code output has
   very little noise.

   You can find the [[https://github.com/jimweirich/emacs-setup-esk/blob/master/eval-buffer.el][original code that he wrote right here]].

   The only thing I've changed is the variable
   =jw-eval-buffer-commands= and instead I've created
   =jedcn-eval-buffer-commands= just because I do not have xruby.

#+begin_src emacs-lisp
  (defconst jedcn-eval-buffer-commands
    '(("js" . "/usr/local/bin/node")
      ("rb" . "ruby")
      ("coffee" . "/usr/local/share/npm/bin/coffee")
      ("clj" . "/Users/jim/local/bin/clojure")
      ("py" . "/usr/bin/python")))
#+end_src

#+begin_src emacs-lisp
  (defconst jw-eval-buffer-name "*EVALBUFFER*")

  (defun jw-eval-buffer ()
    "Evaluate the current buffer and display the result in a buffer."
    (interactive)
    (save-buffer)
    (let* ((file-name (buffer-file-name (current-buffer)))
           (file-extension (file-name-extension file-name))
           (buffer-eval-command-pair (assoc file-extension jedcn-eval-buffer-commands)))
      (if buffer-eval-command-pair
          (let ((command (concat (cdr buffer-eval-command-pair) " " file-name)))
            (shell-command-on-region (point-min) (point-max) command jw-eval-buffer-name nil)
            (pop-to-buffer jw-eval-buffer-name)
            (other-window 1)
            (jw-eval-buffer-pretty-up-errors jw-eval-buffer-name)
            (message ".."))
        (message "Unknown buffer type"))))

  (defun jw-eval-buffer-pretty-up-errors (buffer)
    "Fix up the buffer to highlight the error message (if it contains one)."
    (save-excursion
      (set-buffer buffer)
      (goto-char (point-min))
      (let ((pos (search-forward-regexp "\\.rb:[0-9]+:\\(in.+:\\)? +" (point-max) t)))
        (if pos (progn
                  (goto-char pos)
                  (insert-string "\n\n")
                  (end-of-line)
                  (insert-string "\n"))))))

  (defun jw-clear-eval-buffer ()
    (interactive)
    (save-excursion
      (set-buffer jw-eval-buffer-name)
      (kill-region (point-min) (point-max))))

  (defun jw-eval-or-clear-buffer (n)
    (interactive "P")
    (cond ((null n) (jw-eval-buffer))
          (t (jw-clear-eval-buffer))))
#+end_src
* Appendix A: Installation Details

  This appendix covers both how I install Emacs on MacOS and how I get
  up and running with =emacs-setup=.

** Emacs Installation

   On MacOS I install Emacs using [[http://brew.sh/][Homebrew]]. I run the following,
   inspired by this [[http://emacsredux.com/blog/2013/08/21/color-themes-redux/][Emacs Redux post on color themes]]:

#+begin_src sh :tangle no
  brew install emacs --cocoa --srgb
#+end_src

   This takes some time to complete, and when finished I take another
   step to make Emacs appear as one of my Applications:

#+begin_src sh :tangle no
  ln -s /usr/local/Cellar/emacs/24.3/Emacs.app /Applications
#+end_src

   Now I can start emacs by selecting it graphically in the
   Applications area.

** Cask Installation

   I then use brew to get cask. Cask handles the fetching and
   installation of packages that I use:

#+begin_src sh :tangle no
  brew install cask
#+end_src

** Using =emacs-setup=

   Once I have Emacs 24+ and cask, I use git to clone my =emacs-setup=
   to my machine, cd into the cloned directory, and source the file
   =install.sh=:

#+begin_src shell-script :tangle no
  git clone https://github.com/jedcn/emacs-setup.git
  cd emacs-setup
  source install.sh
#+end_src

   The contents of the =install.sh= file achieve the following:

   + They allow you to supply a =HOME= and will create an =.emacs.d=
     underneath =HOME= if needed.

   + They create a link within this =.emacs.d= back to the cloned
     =emacs-setup=.

   + They create a Cask file, run a =cask install=. This contacts
     melpa and installs all dependent packages.

   + Finally, they copy a =init.el= into HOME so that the next startup
     of Emacs will load the composite =emacs-setup.el=.

#+begin_src sh :tangle install.sh
  emacs_setup_dir=`pwd`

  echo "Creating $HOME/.emacs.d (if needed)"
  mkdir -p $HOME/.emacs.d

  echo "Creating $HOME/.emacs.d/emacs-setup as link to $emacs_setup_dir"
  ln -s $emacs_setup_dir $HOME/.emacs.d/emacs-setup

  echo "Creating $HOME/.emacs.d/init.el"
  cp init.el $HOME/.emacs.d

  echo "Creating $HOME/.emacs.d/Cask"
  cp Cask $HOME/.emacs.d

  pushd $HOME/.emacs.d
  echo "Installing Packages with Cask"
  cask install
  popd
#+end_src

   It is important to note that =HOME= can be given a temporary value
   and this lets me test my installation process. I can get a fresh
   copy of =emacs-setup= and clone it into a temporary directory, and
   then I can run the =install.sh= with a temporary value of =HOME=
   like so:

#+begin_src sh :tangle no
  mkdir /tmp/emacs-setup && cd /tmp/emacs-setup
  git clone https://github.com/jedcn/emacs-setup.git .

  mkdir /tmp/emacs-home
  HOME=/tmp/emacs-home source install.sh
  HOME=/tmp/emacs-home /Applications/Emacs.app/Contents/MacOS/Emacs &
#+end_src
* Appendix B: Babel and the Config

  My configuration is stored as several .org files. This is done to
  optimize for editing and the production of documentation (via
  =org-export=). However, emacs does not read these .org files and
  instead it reads a single elisp file, =emacs-setup.el=.

  How is a single elisp file generated from several .org files? The
  .org files are concatenated together in a specific order to create a
  composite .org file named =emacs-setup.org=. This composite file can
  be used to generate =emacs-setup.el=, and it can also generate
  complete documentation in various formats: HTML or LaTeX/PDF.

  Emacs has built in support for extracting and loading elisp within
  .org files via =org-babel-load-file=. Why not just use this on each
  .org file individually rather than orchestrating a process by which
  they are concatenated into a single, larger document? I want to
  focus on woven documentation. Why not just operate on just a larger
  .org file? I want to work towards modularity. Putting these two
  concepts together, I think of each .org file as a stand-alone entity
  that is both chapter in a larger story and section in a larger
  program.

  The remainder of this appendix details how this orchestration
  works. All of the functions and variables in this section begin with
  =jedcn-es/= to indicate their logical association with my (=jedcn=)
  emacs setup (=es=).

** Composite File

   The name of the composite .org file is =emacs-setup.org=, and its
   location is stored for future reference in =composite-org=.

#+begin_src emacs-lisp
  (setq jedcn-es/composite-org (concat
                                jedcn-es/dir
                                "/emacs-setup.org"))
#+end_src

** Component Files

   The list of files that will be included in the composite file is
   stored in =files=. Order is significant. These files are presumed
   to be within =files-dir=.

#+begin_src emacs-lisp
  (setq jedcn-es/files-dir (concat
                            jedcn-es/dir
                            "/org"))

  (setq jedcn-es/files '("introduction.org"
                         "general-setup.org"
                         "personal-information.org"
                         "key-bindings.org"
                         "behaviors.org"
                         "modes.org"
                         "various-and-sundry.org"
                         "appendix-a.org"
                         "appendix-b.org"))
#+end_src

** Concatenation

   The composite file is created with =create-composite-org=, which in
   turn relies on =concat-files=, =files-dir=, and =files=, and
   =composite-org=.

#+begin_src emacs-lisp
  (defun jedcn-es/concat-files (the-files target-file)
    "Concatenate a list of THE-FILES into a TARGET-FILE"
    (let* ((original-buffer (current-buffer))
           (result-file target-file)
           (files the-files)
           (file (car files)))
      ;; do..
      (find-file file)
      (write-region (point-min) (point-max) result-file)
      (setq files (cdr files))
      (setq file (car files))
      ;; while
      (while files
        (find-file file)
        (write-region (point-min) (point-max) result-file t)
        (setq files (cdr files))
        (setq file (car files)))
      (switch-to-buffer original-buffer)))

  (defun jedcn-es/create-composite-org ()
    "Create a composite org file based on my list of config files"
    (jedcn-es/concat-files
     (mapcar (lambda (file)
               (concat jedcn-es/files-dir "/" file))
             jedcn-es/files)
     jedcn-es/composite-org))
#+end_src

** Extracting elisp

   Literate programming uses the verb "tangling" to describe the
   extraction of pure source code from its annotated source. We'll aim
   to extract the elisp from =composite-org= and place it into
   =composite-el=.

#+begin_src emacs-lisp
  (setq jedcn-es/composite-el (concat jedcn-es/dir "/emacs-setup.el"))
#+end_src

   Babel supports code extraction with a function named
   =org-babel-tangle-file=, and we can hook into the process described
   above as follows:

#+begin_src emacs-lisp
  (defun jedcn-es/tangle-composite-org ()
    (org-babel-tangle-file jedcn-es/composite-org jedcn-es/composite-el))
#+end_src

   When this has completed, we will have the tangled result residing
   at =composite-el=. The next logical step is to load it up and try
   it out:

#+begin_src emacs-lisp
  (defun jedcn-es/load-composite-el ()
    (load-file jedcn-es/composite-el))
#+end_src

   Stepping back, we can bundle up the creation of the composite .org
   file from its component pieces, then tangle it, and then load the
   result with =jedcn-es/rebuild-and-reload=:

#+begin_src emacs-lisp
  (defun jedcn-es/rebuild-and-reload ()
    "Rebuild the composite .org file, extract the elisp, and reload"
    (interactive)
    (jedcn-es/create-composite-org)
    (jedcn-es/tangle-composite-org)
    (jedcn-es/load-composite-el))
#+end_src

   This is the only function I make interactive. In practice, this
   means that I can fool around with my .org files, and then =M-x
   jedcn-es/rebuild-and-reload= to try out the latest changes.
